<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chess Bot — fixed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- chessboard css -->
  <link rel="stylesheet"
        href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
        crossorigin="anonymous">
  <style>
    body { background: #fafafa; margin:0; font-family: Arial, Helvetica, sans-serif; }
    .board-container { max-width: 480px; margin: 48px auto; }
    #myBoard { width: 100%; }

    /* click highlights */
    .highlight-click { box-shadow: inset 0 0 8px 4px rgba(255,165,0,0.95); }
    .highlight-target { box-shadow: inset 0 0 6px 3px rgba(50,205,50,0.9); }

    /* small move flash */
    .move-effect { animation: boardMoveEffect 380ms ease-out; }
    @keyframes boardMoveEffect {
      0% { box-shadow: 0 0 18px 6px rgba(60,200,60,0.95) inset; }
      100% { box-shadow: none; }
    }

    /* Make chessboard.js piece movement smooth */
    /* selector matches chessboard's piece nodes */
    .chessboard-1x .piece {
      transition: top 220ms ease, left 220ms ease;
      will-change: top, left;
    }
  </style>
</head>
<body>
  <div class="board-container">
    <div id="myBoard"></div>
  </div>

  <!-- sounds -->
  <audio id="moveSound" src="sounds/move.mp3"></audio>
  <audio id="captureSound" src="sounds/capture.mp3"></audio>
  <audio id="promoteSound" src="sounds/promote.mp3"></audio>
  <audio id="castlingSound" src="sounds/castling.mp3"></audio>
  <audio id="incorrectMoveSound" src="sounds/incorrect-move.mp3"></audio>
  <audio id="checkSound" src="sounds/check.mp3"></audio>
  <audio id="checkmateSound" src="sounds/checkmate.mp3"></audio>

  <!-- libs -->
  <script src="https://code.jquery.com/jquery-3.5.1.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js" crossorigin="anonymous"></script>
  <!-- local chess logic -->
  <script src="js/chess.js"></script>

  <script>
  // ========= Configuration =========
  var pieceTheme = {
    'wK':'pieces/wK.svg','wQ':'pieces/wQ.svg','wR':'pieces/wR.svg',
    'wB':'pieces/wB.svg','wN':'pieces/wN.svg','wP':'pieces/wP.svg',
    'bK':'pieces/bK.svg','bQ':'pieces/bQ.svg','bR':'pieces/bR.svg',
    'bB':'pieces/bB.svg','bN':'pieces/bN.svg','bP':'pieces/bP.svg'
  };

  function pieceThemeFunc(piece) { return pieceTheme[piece]; }

  // ========= State =========
  var board = null;
  var game = new Chess(); // from js/chess.js
  var pendingMove = null; // used for drag-flow: { illegal:bool } or { move:..., from:..., to:..., flow:'drag'}
  var selectedSquare = null;
  var legalTargets = [];

  // ========= Audio helpers =========
  function playSound(name) {
    var el = document.getElementById({
      move:'moveSound', capture:'captureSound', promote:'promoteSound',
      castling:'castlingSound', incorrect:'incorrectMoveSound',
      check:'checkSound', checkmate:'checkmateSound'
    }[name]);
    if (!el) return;
    try { el.currentTime = 0; el.play(); } catch(e){ /* autoplay blocked? ignore */ }
  }

  // small flash effect on squares
  function flashSquares(sqs) {
    sqs.forEach(function(sq){
      var $sq = $('#myBoard .square-' + sq);
      $sq.addClass('move-effect');
      setTimeout(function(){ $sq.removeClass('move-effect'); }, 420);
    });
  }

  function playMoveEffects(move) {
    if (!move) return;
    if (move.flags.indexOf('k') !== -1 || move.flags.indexOf('q') !== -1) {
      playSound('castling');
    } else if (move.flags.indexOf('p') !== -1) {
      playSound('promote');
    } else if (move.flags.indexOf('c') !== -1 || move.flags.indexOf('e') !== -1) {
      playSound('capture');
    } else {
      playSound('move');
    }
    if (game.in_checkmate()) playSound('checkmate');
    else if (game.in_check()) playSound('check');
  }

  // ========= Board config =========
  var config = {
    draggable: true,
    position: 'start',
    pieceTheme: pieceThemeFunc,
    onDragStart: onDragStart,
    onDrop: onDrop,
    onSnapEnd: onSnapEnd,
    onMouseoverSquare: onMouseoverSquare,
    onMouseoutSquare: onMouseoutSquare,
    moveSpeed: 220,
    snapbackSpeed: 220,
    snapSpeed: 120
  };
  board = Chessboard('myBoard', config);

  // ========= Drag-flow handlers (fixed) =========
  function onDragStart(source, piece) {
    if (game.game_over()) return false;
    // only allow dragging player's pieces
    if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
    // clear click selection when dragging
    clearSelection();
  }

  // onDrop must not call board.position immediately — set pendingMove and let onSnapEnd finish animation.
  function onDrop(source, target) {
    // reset pending
    pendingMove = null;

    // clear preview greys
    removeGreySquares();

    // attempt move on internal game
    var move = game.move({ from: source, to: target, promotion: 'q' });
    if (move === null) {
      // illegal -> ask board to snapback; remember illegal to play sound once on snap end
      pendingMove = { illegal: true, flow: 'drag' };
      return 'snapback';
    }

    // legal: set pending for onSnapEnd to handle effects & bot move
    pendingMove = { illegal: false, flow: 'drag', move: move, from: source, to: target };
    // Return undefined so board will complete the drag-to-square animation then call onSnapEnd.
    return;
  }

  // after the piece animation completes, sync board->game and play sounds/effects once
  function onSnapEnd() {
    // Always update visual to the current game.fen() (keeps board and game synced)
    board.position(game.fen());

    if (!pendingMove) return;

    if (pendingMove.flow === 'drag') {
      if (pendingMove.illegal) {
        // illegal: play incorrect sound ONCE (snapback animation already ran)
        playSound('incorrect');
      } else {
        // legal: play sound/effect and then run bot
        playMoveEffects(pendingMove.move);
        flashSquares([pendingMove.from, pendingMove.to]);
        // small delay to let user see move effect before bot moves
        setTimeout(function(){
          if (!game.game_over() && game.turn() === 'b') {
            makeBotMove();
          }
        }, 300);
      }
    }

    // clear pending
    pendingMove = null;
  }

  // ========= Mouse hover helpers (same as original) =========
  var whiteSquareGrey = '#a9a9a9';
  var blackSquareGrey = '#696969';

  function removeGreySquares() {
    $('#myBoard .square-55d63').css('background', '');
  }
  function greySquare(square) {
    var $square = $('#myBoard .square-' + square);
    var background = whiteSquareGrey;
    if ($square.hasClass('black-3c85d')) background = blackSquareGrey;
    $square.css('background', background);
  }
  function onMouseoverSquare(square, piece) {
    var moves = game.moves({ square: square, verbose: true });
    if (moves.length === 0) return;
    greySquare(square);
    for (var i = 0; i < moves.length; i++) greySquare(moves[i].to);
  }
  function onMouseoutSquare(square, piece) { removeGreySquares(); }

  // ========= Click-to-move (fixed & uses board.move animation) =========
  // Behavior: click piece -> highlight; click target -> attempt move; illegal -> play incorrect; legal -> animate using board.move()
  function clearSelection() {
    selectedSquare = null;
    legalTargets = [];
    $('#myBoard .square-55d63').removeClass('highlight-click highlight-target');
  }

  $('#myBoard').on('click', '.square-55d63', function (e) {
    var square = $(this).attr('data-square');
    if (game.game_over()) return;
    // if nothing selected: try to select player's piece
    if (!selectedSquare) {
      var piece = game.get(square);
      if (!piece || piece.color !== game.turn()) return;
      selectedSquare = square;
      clearSelection();
      $('#myBoard .square-' + square).addClass('highlight-click');
      var moves = game.moves({ square: square, verbose: true });
      legalTargets = moves.map(function(m){ return m.to; });
      legalTargets.forEach(function(s){ $('#myBoard .square-' + s).addClass('highlight-target'); });
      return;
    }

    // if clicked the same square -> deselect
    if (selectedSquare === square) { clearSelection(); return; }

    // if clicked one of legal targets -> perform move via game.move then animate with board.move
    if (legalTargets.indexOf(square) !== -1) {
      // perform move on game first
      var move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
      if (move === null) {
        // should not happen, but handle
        playSound('incorrect');
        clearSelection();
        board.position(game.fen());
        return;
      }

      // animate using board.move so movement is smooth and single (no double animation)
      // chessboard.js supports board.move('e2-e4') style
      try {
        board.move(selectedSquare + '-' + square);
      } catch (err) {
        // fallback: set position directly
        board.position(game.fen());
      }

      // play effects/sounds and flash squares
      playMoveEffects(move);
      flashSquares([selectedSquare, square]);

      // clear selection visuals
      clearSelection();

      // schedule bot after short delay (allow animation to complete)
      setTimeout(function(){
        if (!game.game_over() && game.turn() === 'b') makeBotMove();
      }, 350);

      return;
    }

    // If clicked another own piece -> switch selection
    var piece2 = game.get(square);
    if (piece2 && piece2.color === game.turn()) {
      selectedSquare = square;
      clearSelection();
      $('#myBoard .square-' + square).addClass('highlight-click');
      var moves = game.moves({ square: square, verbose: true });
      legalTargets = moves.map(function(m){ return m.to; });
      legalTargets.forEach(function(s){ $('#myBoard .square-' + s).addClass('highlight-target'); });
      return;
    }

    // anything else -> deselect
    clearSelection();
  });

  // deselect if clicked outside board
  $(document).on('click', function(e){
    if ($(e.target).closest('#myBoard').length === 0) clearSelection();
  });

  // clear selection on manual drag start
  $('#myBoard').on('mousedown', '.square-55d63', function(){ clearSelection(); });

  // ========= Bot move helpers =========
  // Use the project's minimax functions (copied from original main.js). Keep minimal depth for interactivity.
  function getBestMoveForBlack() {
    // Use depth 2 (fast). If you want, expose a control to increase depth.
    var depth = 5;
    // We call minimax implemented elsewhere in your code base (if you removed it earlier ensure it's present).
    // The project uses functions minimax(...) and evaluateBoard(...). We call a thin wrapper here:
    try {
      var result = minimax(game, depth, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, true, /*sum*/ 0, 'b');
      return result ? result[0] : null;
    } catch (err) {
      // If minimax isn't reachable in global scope (unlikely if you kept js/main.js),
      // fallback to a random legal move:
      var moves = game.moves({ verbose:true });
      if (!moves || moves.length === 0) return null;
      return moves[Math.floor(Math.random()*moves.length)];
    }
  }

  function makeBotMove() {
    // compute best move object (pretty move) or null
    var best = getBestMoveForBlack();
    if (!best) return;
    // apply to game
    try {
      var pretty = game.move(best); // best may already be a prettified object from minimax/ugly_move
      if (!pretty) {
        // if minimax returned a move object that is not recognized, try to construct a move object
        // fallback: get a random legal move
        var ms = game.moves({ verbose:true });
        if (ms.length === 0) return;
        pretty = game.move(ms[Math.floor(Math.random()*ms.length)]);
      }
    } catch(e) {
      return;
    }

    // Animate bot move using board.move (smooth)
    try {
      board.move(best.from + '-' + best.to);
    } catch (err) {
      board.position(game.fen());
    }

    // Sounds/effects for bot's move:
    playMoveEffects(pretty);
    flashSquares([pretty.from, pretty.to]);
  }

  // ========= Fixes summary =========
  // - Drag flow: we only call game.move() in onDrop and DO NOT call board.position() there.
  //   onSnapEnd updates the board and plays sounds/effects — this prevents the "double animation" glitch.
  // - Click flow: after game.move() we call board.move("e2-e4") to animate the piece once (no duplicate).
  // - Incorrect-move sound now plays only when a true illegal move returned by game.move() happens (drag or click).
  // - All move sounds/effects are played exactly once per successful move.

  // small safety: ensure chessboard piece nodes have the smooth transition after docs load
  setTimeout(function(){
    $('#myBoard .piece').css('transition','top 220ms ease,left 220ms ease');
  }, 600);

  </script>
</body>
</html>
