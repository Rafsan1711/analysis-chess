<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chess Analysis Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" crossorigin="anonymous">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #e0e0e0;
      min-height: 100vh;
      padding: 20px;
    }
    
    body.scroll-locked {
      overflow: hidden;
      touch-action: none;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }
    
    .board-section {
      display: flex;
      gap: 15px;
      flex: 1;
      min-width: 320px;
    }
    
    /* Evaluation Bar */
    .eval-bar-container {
      width: 50px;
      position: relative;
      background: #1a1a1a;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
      border: 2px solid #333;
    }
    
    .eval-bar {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: linear-gradient(to top, #ffffff 0%, #e8e8e8 100%);
      transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .eval-bar-black {
      position: absolute;
      top: 0;
      width: 100%;
      background: linear-gradient(to bottom, #2c2c2c 0%, #1a1a1a 100%);
      transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .eval-number {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: bold;
      z-index: 10;
      min-width: 42px;
      text-align: center;
      border: 1px solid #444;
    }
    
    /* Player Names */
    .player-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: #2a2a3e;
      border-radius: 6px;
      margin-bottom: 5px;
      font-size: 13px;
    }
    
    .player-name {
      font-weight: 600;
      color: #e0e0e0;
    }
    
    .player-elo {
      color: #888;
      font-size: 11px;
      margin-left: 6px;
    }
    
    /* Board */
    .board-wrapper {
      flex: 1;
      max-width: 500px;
    }
    
    #myBoard { 
      width: 100% !important;
      box-shadow: 0 8px 25px rgba(0,0,0,0.5);
      border-radius: 8px;
      overflow: hidden;
    }
    
    /* Controls */
    .controls {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    
    .controls button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      color: white;
      padding: 10px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
      box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(102, 126, 234, 0.5);
    }
    
    .controls button:active {
      transform: translateY(0);
    }
    
    .controls button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }
    
    .controls button.toggle-active {
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
    }
    
    /* PGN Section */
    .pgn-section {
      flex: 1;
      min-width: 300px;
      background: #2a2a3e;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }
    
    .pgn-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #667eea;
    }
    
    .pgn-header h3 {
      color: #667eea;
      font-size: 18px;
    }
    
    .header-buttons {
      display: flex;
      gap: 8px;
    }
    
    .icon-btn {
      background: #667eea;
      border: none;
      color: white;
      width: 32px;
      height: 32px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .icon-btn:hover {
      background: #764ba2;
      transform: scale(1.05);
    }
    
    /* PGN Table */
    .pgn-table-container {
      max-height: 500px;
      overflow-y: auto;
      background: #1e1e2e;
      border-radius: 8px;
      padding: 10px;
    }
    
    .pgn-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .pgn-table th {
      background: #667eea;
      color: white;
      padding: 10px;
      text-align: left;
      position: sticky;
      top: 0;
      z-index: 5;
      font-size: 13px;
    }
    
    .pgn-table td {
      padding: 8px 10px;
      border-bottom: 1px solid #3a3a4e;
      font-size: 14px;
    }
    
    .pgn-table tr:hover {
      background: #3a3a5e;
    }
    
    .pgn-table .move-number {
      color: #888;
      width: 50px;
      text-align: center;
      font-weight: 600;
    }
    
    .pgn-table .move-cell {
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .pgn-table .move-cell:hover {
      color: #667eea;
      font-weight: bold;
    }
    
    .pgn-table .move-cell.current {
      background: #667eea;
      color: white;
      font-weight: bold;
    }
    
    .move-text {
      display: inline-block;
      min-width: 60px;
    }
    
    .move-icon {
      float: right;
      margin-left: 8px;
    }
    
    /* Modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.85);
      backdrop-filter: blur(5px);
    }
    
    .modal-content {
      background: #2a2a3e;
      margin: 5% auto;
      padding: 30px;
      border-radius: 12px;
      max-width: 600px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      animation: modalSlideIn 0.3s ease;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    @keyframes modalSlideIn {
      from { transform: translateY(-50px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .modal-content h2 {
      color: #667eea;
      margin-bottom: 20px;
    }
    
    .icon-legend {
      display: grid;
      gap: 12px;
    }
    
    .icon-item {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 10px;
      background: #1e1e2e;
      border-radius: 6px;
    }
    
    .icon-item svg {
      flex-shrink: 0;
    }
    
    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: color 0.2s;
      line-height: 20px;
    }
    
    .close:hover { color: #667eea; }
    
    /* PGN Input Modal */
    .pgn-input-area {
      width: 100%;
      min-height: 200px;
      background: #1e1e2e;
      border: 2px solid #667eea;
      border-radius: 8px;
      padding: 15px;
      color: #e0e0e0;
      font-family: monospace;
      font-size: 13px;
      resize: vertical;
      margin-bottom: 15px;
    }
    
    .pgn-input-area:focus {
      outline: none;
      border-color: #764ba2;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
    }
    
    .submit-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      color: white;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      width: 100%;
      transition: all 0.2s;
    }
    
    .submit-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(102, 126, 234, 0.5);
    }
    
    /* Status */
    .status-bar {
      text-align: center;
      margin-top: 10px;
      padding: 8px;
      background: #1e1e2e;
      border-radius: 6px;
      font-size: 13px;
      color: #888;
    }
    
    .analyzing {
      color: #667eea;
      font-weight: bold;
    }
    
    .progress-bar {
      width: 100%;
      height: 4px;
      background: #1e1e2e;
      border-radius: 2px;
      margin-top: 5px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      width: 0%;
      transition: width 0.3s;
    }
    
    /* Scrollbar */
    .pgn-table-container::-webkit-scrollbar,
    .modal-content::-webkit-scrollbar {
      width: 8px;
    }
    
    .pgn-table-container::-webkit-scrollbar-track,
    .modal-content::-webkit-scrollbar-track {
      background: #1e1e2e;
      border-radius: 4px;
    }
    
    .pgn-table-container::-webkit-scrollbar-thumb,
    .modal-content::-webkit-scrollbar-thumb {
      background: #667eea;
      border-radius: 4px;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      
      .board-section {
        width: 100%;
      }
      
      .board-wrapper {
        max-width: calc(100vw - 90px);
      }
      
      .pgn-section {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="board-section">
      <div class="eval-bar-container">
        <div class="eval-bar-black" id="evalBarBlack" style="height: 50%;"></div>
        <div class="eval-bar" id="evalBar" style="height: 50%;"></div>
        <div class="eval-number" id="evalNumber">0.0</div>
      </div>
      
      <div class="board-wrapper">
        <div class="player-info" id="blackPlayer">
          <span class="player-name">Black</span>
        </div>
        
        <div id="myBoard"></div>
        
        <div class="player-info" id="whitePlayer">
          <span class="player-name">White</span>
        </div>
        
        <div class="controls">
          <button id="firstBtn" title="First Move">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M11.5 3L5.5 8l6 5V3z"/>
              <path d="M4 3h1v10H4V3z"/>
            </svg>
          </button>
          <button id="prevBtn" title="Previous Move">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M11.5 3L5.5 8l6 5V3z"/>
            </svg>
          </button>
          <button id="nextBtn" title="Next Move">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M4.5 3l6 5-6 5V3z"/>
            </svg>
          </button>
          <button id="lastBtn" title="Last Move">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M4.5 3l6 5-6 5V3z"/>
              <path d="M11 3h1v10h-1V3z"/>
            </svg>
          </button>
          <button id="flipBtn" title="Flip Board">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M8 3l4 4H4l4-4zM8 13l-4-4h8l-4 4z"/>
            </svg>
          </button>
          <button id="lockScrollBtn" title="Lock Scroll (for mobile drag)">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M8 1a3 3 0 013 3v2h1a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1V7a1 1 0 011-1h1V4a3 3 0 013-3zm0 1a2 2 0 00-2 2v2h4V4a2 2 0 00-2-2z"/>
            </svg>
          </button>
          <button id="analyzeBtn" title="Analyze All Moves">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <circle cx="7" cy="7" r="5" stroke="currentColor" fill="none" stroke-width="2"/>
              <path d="M10.5 10.5l3.5 3.5"/>
            </svg>
          </button>
        </div>
        <div class="status-bar" id="statusBar">Ready to analyze</div>
        <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
      </div>
    </div>
    
    <div class="pgn-section">
      <div class="pgn-header">
        <h3>Move List</h3>
        <div class="header-buttons">
          <button class="icon-btn" id="pgnInputBtn" title="Import PGN">
            <svg width="18" height="18" viewBox="0 0 16 16" fill="currentColor">
              <path d="M8 2v8m0 0l3-3m-3 3L5 7"/>
              <path d="M3 12v1a1 1 0 001 1h8a1 1 0 001-1v-1" stroke="currentColor" fill="none"/>
            </svg>
          </button>
          <button class="icon-btn" id="infoBtn" title="Legend">i</button>
        </div>
      </div>
      <div class="pgn-table-container">
        <table class="pgn-table">
          <thead>
            <tr>
              <th>#</th>
              <th>White</th>
              <th>Black</th>
            </tr>
          </thead>
          <tbody id="pgnTableBody">
            <tr>
              <td colspan="3" style="text-align:center; color:#888;">No moves yet</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Info Modal -->
  <div id="infoModal" class="modal">
    <div class="modal-content">
      <span class="close" id="closeModal">&times;</span>
      <h2>Move Annotations</h2>
      <div class="icon-legend">
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#4ade80"/><text x="10" y="15" text-anchor="middle" font-size="14" fill="white" font-weight="bold">✓</text></svg>
          <div><strong>Best Move</strong> - Engine's top choice (±10cp)</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#22c55e"/><text x="10" y="15" text-anchor="middle" font-size="14" fill="white" font-weight="bold">!</text></svg>
          <div><strong>Great Move</strong> - Excellent move (loss <30cp)</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#84cc16"/><circle cx="10" cy="10" r="3" fill="white"/></svg>
          <div><strong>Good Move</strong> - Solid move (loss 10-50cp)</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#f59e0b"/><text x="10" y="15" text-anchor="middle" font-size="12" fill="white" font-weight="bold">?!</text></svg>
          <div><strong>Inaccuracy</strong> - Minor mistake (loss 50-150cp)</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#f97316"/><text x="10" y="15" text-anchor="middle" font-size="14" fill="white" font-weight="bold">?</text></svg>
          <div><strong>Mistake</strong> - Clear error (loss 150-300cp)</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#ef4444"/><text x="10" y="12" text-anchor="middle" font-size="10" fill="white" font-weight="bold">??</text></svg>
          <div><strong>Blunder</strong> - Serious mistake (loss >300cp)</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><defs><linearGradient id="brilliantGrad"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#f59e0b"/></linearGradient></defs><circle cx="10" cy="10" r="9" fill="url(#brilliantGrad)"/><text x="10" y="15" text-anchor="middle" font-size="14" fill="white">⭐</text></svg>
          <div><strong>Brilliant</strong> - Spectacular sacrificial move</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#3b82f6"/><text x="10" y="12" text-anchor="middle" font-size="10" fill="white" font-weight="bold">!?</text></svg>
          <div><strong>Interesting</strong> - Creative alternative</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><rect width="20" height="20" rx="3" fill="#6366f1"/><text x="10" y="15" text-anchor="middle" font-size="14" fill="white">📖</text></svg>
          <div><strong>Book Move</strong> - Opening theory</div>
        </div>
      </div>
    </div>
  </div>

  <!-- PGN Input Modal -->
  <div id="pgnModal" class="modal">
    <div class="modal-content">
      <span class="close" id="closePgnModal">&times;</span>
      <h2>Import PGN</h2>
      <textarea class="pgn-input-area" id="pgnInput" placeholder="Paste your PGN here...

Example:
[Event &quot;Game&quot;]
[White &quot;Player1&quot;]
[Black &quot;Player2&quot;]

1. e4 e5 2. Nf3 Nc6 3. Bb5..."></textarea>
      <button class="submit-btn" id="submitPgn">Load Game</button>
    </div>
  </div>

  <!-- Audio -->
  <audio id="moveSound" src="sounds/move.mp3"></audio>
  <audio id="captureSound" src="sounds/capture.mp3"></audio>

  <!-- Scripts -->
  <script src="https://code.jquery.com/jquery-3.5.1.js"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
  <script src="js/chess.js"></script>

  <script>
  // ========================
  // Piece Theme Resolver
  // ========================
  var pieceCandidates = {
    'wK':['pieces/wK.svg','pieces/wKing.svg'], 'wQ':['pieces/wQ.svg','pieces/wQueen.svg'],
    'wR':['pieces/wR.svg','pieces/wRook.svg'], 'wB':['pieces/wB.svg','pieces/wBishop.svg'],
    'wN':['pieces/wN.svg','pieces/wKnight.svg'], 'wP':['pieces/wP.svg','pieces/wPawn.svg'],
    'bK':['pieces/bK.svg','pieces/bKing.svg'], 'bQ':['pieces/bQ.svg','pieces/bQueen.svg'],
    'bR':['pieces/bR.svg','pieces/bRook.svg'], 'bB':['pieces/bB.svg','pieces/bBishop.svg'],
    'bN':['pieces/bN.svg','pieces/bKnight.svg'], 'bP':['pieces/bP.svg','pieces/bPawn.svg']
  };
  var pieceImgResolved = {};

  function loadImage(url){ return new Promise((resolve,reject)=> { var img=new Image(); img.onload=()=>resolve(url); img.onerror=()=>reject(url); img.src=url; }); }
  async function resolvePiece(key, candidates){
    for (var i=0;i<candidates.length;i++){
      try{ return await loadImage(candidates[i]); } catch(e){}
    }
    return null;
  }
  async function resolveAllPieces(){
    for (var key in pieceCandidates) { pieceImgResolved[key] = await resolvePiece(key, pieceCandidates[key]); }
    var defaultAny=null; for (var k in pieceImgResolved) if (pieceImgResolved[k]) { defaultAny = pieceImgResolved[k]; break; }
    for (var k2 in pieceImgResolved) if (!pieceImgResolved[k2]) pieceImgResolved[k2] = defaultAny;
    return pieceImgResolved;
  }

  // ========================
  // Stockfish Engine with Queue System
  // ========================
  var stockfishEngine = null;
  var engineReady = false;
  var analysisQueue = [];
  var isProcessingQueue = false;

  function createStockfishBlobWorker(cdnUrl) {
    try {
      var blobCode = "importScripts('" + cdnUrl + "');";
      var blob = new Blob([blobCode], {type: 'application/javascript'});
      var blobURL = URL.createObjectURL(blob);
      return new Worker(blobURL);
    } catch (e) {
      return null;
    }
  }

  function initStockfish() {
    try {
      var cdn = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
      stockfishEngine = createStockfishBlobWorker(cdn);
      
      stockfishEngine.onmessage = function(e) {
        var line = e.data;
        if (line.indexOf('readyok') !== -1) {
          engineReady = true;
          console.log('Stockfish ready');
          document.getElementById('statusBar').textContent = 'Engine ready';
        }
      };
      
      stockfishEngine.postMessage('uci');
      stockfishEngine.postMessage('setoption name Threads value 2');
      stockfishEngine.postMessage('setoption name Hash value 128');
      stockfishEngine.postMessage('setoption name Skill Level value 20');
      stockfishEngine.postMessage('isready');
    } catch (e) {
      console.error('Stockfish init failed:', e);
    }
  }

  // Queue-based evaluation to prevent "engine busy" errors
  function evaluatePositionDetailed(fen, depth) {
    return new Promise((resolve, reject) => {
      if (!stockfishEngine || !engineReady) {
        return reject('engine not ready');
      }
      
      analysisQueue.push({ fen: fen, depth: depth, resolve: resolve, reject: reject });
      processQueue();
    });
  }

  async function processQueue() {
    if (isProcessingQueue || analysisQueue.length === 0) return;
    
    isProcessingQueue = true;
    var task = analysisQueue.shift();
    
    try {
      var result = await runAnalysis(task.fen, task.depth);
      task.resolve(result);
    } catch (e) {
      task.reject(e);
    }
    
    isProcessingQueue = false;
    
    // Process next in queue
    if (analysisQueue.length > 0) {
      setTimeout(processQueue, 50);
    }
  }

  function runAnalysis(fen, depth) {
    return new Promise((resolve, reject) => {
      var timeout = setTimeout(() => {
        reject('timeout');
      }, 12000);
      
      var result = { score: 0, bestMove: null, pvLine: [] };
      var lastDepth = 0;
      
      var handler = function(e) {
        var line = e.data;
        
        if (line.indexOf('info depth') !== -1) {
          var depthMatch = line.match(/depth (\d+)/);
          if (depthMatch) lastDepth = parseInt(depthMatch[1]);
          
          if (line.indexOf('pv ') !== -1) {
            var pvMatch = line.match(/pv\s+(\S+)/);
            if (pvMatch) result.pvLine = [pvMatch[1]];
          }
          
          if (line.indexOf('score cp') !== -1) {
            var match = line.match(/score cp (-?\d+)/);
            if (match) result.score = parseInt(match[1]);
          } else if (line.indexOf('score mate') !== -1) {
            var match = line.match(/score mate (-?\d+)/);
            if (match) {
              var mateIn = parseInt(match[1]);
              result.score = mateIn > 0 ? 10000 + mateIn : -10000 - mateIn;
            }
          }
        }
        
        if (line.indexOf('bestmove') === 0) {
          clearTimeout(timeout);
          stockfishEngine.onmessage = null;
          var parts = line.split(' ');
          result.bestMove = parts[1];
          result.depth = lastDepth;
          resolve(result);
        }
      };
      
      stockfishEngine.onmessage = handler;
      stockfishEngine.postMessage('position fen ' + fen);
      stockfishEngine.postMessage('go depth ' + depth);
    });
  }

  // Material value calculator
  var pieceValues = { 'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 0 };
  
  function calculateMaterialLoss(move) {
    if (!move.captured) return 0;
    return pieceValues[move.captured] || 0;
  }

  // ========================
  // Game State
  // ========================
  var board = null;
  var game = new Chess();
  var moveHistory = [];
  var currentMoveIndex = -1;
  var analysisData = {};
  var gameMetadata = { white: 'White', black: 'Black', whiteElo: '', blackElo: '', event: '', date: '' };
  var scrollLocked = false;

  // ========================
  // Board Init
  // ========================
  (async function init() {
    await resolveAllPieces();
    initStockfish();

    function pieceTheme(piece) {
      return pieceImgResolved[piece] || pieceImgResolved['wK'];
    }

    var config = {
      draggable: true,
      position: 'start',
      pieceTheme: pieceTheme,
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd
    };
    
    board = Chessboard('myBoard', config);
    updatePGNTable();
    updateEvalBar(0);
  })();

  function onDragStart(source, piece) {
    if (game.game_over()) return false;
    if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
  }

  function onDrop(source, target) {
    var move = game.move({
      from: source,
      to: target,
      promotion: 'q'
    });

    if (move === null) {
      playSound('move');
      return 'snapback';
    }

    playSound(move.captured ? 'capture' : 'move');
    moveHistory.push(move);
    currentMoveIndex = moveHistory.length - 1;
    updatePGNTable();
    
    // Auto-analyze the move immediately
    var moveIndex = moveHistory.length - 1;
    if (engineReady) {
      analyzeMove(moveIndex).then(function() {
        console.log('Move analyzed successfully');
      }).catch(function(e) {
        console.error('Analysis failed:', e);
      });
    } else {
      document.getElementById('statusBar').textContent = 'Engine not ready yet';
    }
  }

  function onSnapEnd() {
    board.position(game.fen());
  }

  // ========================
  // Enhanced Move Analysis
  // ========================
  async function analyzeMove(moveIndex) {
    if (!engineReady) {
      console.log('Engine not ready');
      return;
    }
    
    console.log('Starting analysis for move', moveIndex);
    document.getElementById('statusBar').innerHTML = '<span class="analyzing">Analyzing move ' + (moveIndex + 1) + '...</span>';
    
    try {
      // Build position before move
      var tempGame = new Chess();
      for (var i = 0; i < moveIndex; i++) {
        tempGame.move(moveHistory[i]);
      }
      
      var prevFen = tempGame.fen();
      var move = moveHistory[moveIndex];
      
      console.log('Evaluating position before move:', prevFen);
      
      // Get evaluation before move (depth 16)
      var prevEval = await evaluatePositionDetailed(prevFen, 16);
      
      console.log('Prev eval:', prevEval);
      
      // Apply the move
      tempGame.move(move);
      var currFen = tempGame.fen();
      
      console.log('Evaluating position after move:', currFen);
      
      // Get evaluation after move (depth 16)
      var currEval = await evaluatePositionDetailed(currFen, 16);
      
      console.log('Curr eval:', currEval);
      
      // Calculate if this was the best move
      var movingColor = move.color;
      var actualMoveNotation = move.from + move.to + (move.promotion || '');
      var wasBestMove = (prevEval.bestMove === actualMoveNotation);
      
      // Calculate evaluation drop from moving player's perspective
      var evalBefore, evalAfter;
      if (movingColor === 'w') {
        evalBefore = prevEval.score;
        evalAfter = -currEval.score;
      } else {
        evalBefore = -prevEval.score;
        evalAfter = currEval.score;
      }
      
      var evalDrop = evalBefore - evalAfter;
      
      console.log('Eval drop:', evalDrop, 'Was best move:', wasBestMove);
      
      // Material loss
      var materialLoss = calculateMaterialLoss(move);
      
      // Enhanced classification
      var classification = classifyMoveEnhanced(evalDrop, materialLoss, wasBestMove, moveIndex, move);
      
      console.log('Classification:', classification);
      
      analysisData[moveIndex] = {
        prevEval: prevEval.score,
        currEval: currEval.score,
        evalDrop: evalDrop,
        bestMove: prevEval.bestMove,
        wasBestMove: wasBestMove,
        materialLoss: materialLoss,
        classification: classification
      };
      
      updatePGNTable();
      updateEvalBar(currEval.score);
      document.getElementById('statusBar').textContent = 'Move ' + (moveIndex + 1) + ' analyzed: ' + classification;
      
      return analysisData[moveIndex];
    } catch (e) {
      console.error('Analysis error for move', moveIndex, ':', e);
      document.getElementById('statusBar').textContent = 'Analysis error: ' + e;
      throw e;
    }
  }

  function classifyMoveEnhanced(evalDrop, materialLoss, wasBestMove, moveIndex, move) {
    // Book moves (first 8 moves)
    if (moveIndex < 8) return 'book';
    
    // Brilliant: Sacrifice that gains significant advantage
    if (materialLoss >= 300 && evalDrop < -30) return 'brilliant';
    
    // Best move: Engine's choice or within 10cp
    if (wasBestMove || evalDrop <= 10) return 'best';
    
    // Great: Strong move, losing less than 30cp
    if (evalDrop <= 30) return 'great';
    
    // Good: Decent move, losing 30-50cp
    if (evalDrop <= 50) return 'good';
    
    // Inaccuracy: Minor mistake, losing 50-150cp
    if (evalDrop <= 150) return 'inaccuracy';
    
    // Mistake: Clear error, losing 150-300cp
    if (evalDrop <= 300) return 'mistake';
    
    // Blunder: Major mistake, losing 300+ cp
    return 'blunder';
  }

  function getMoveIcon(classification) {
    switch(classification) {
      case 'best':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#4ade80"/><text x="8" y="12" text-anchor="middle" font-size="11" fill="white" font-weight="bold">✓</text></svg>';
      case 'great':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#22c55e"/><text x="8" y="12" text-anchor="middle" font-size="11" fill="white" font-weight="bold">!</text></svg>';
      case 'good':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#84cc16"/><circle cx="8" cy="8" r="2.5" fill="white"/></svg>';
      case 'inaccuracy':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#f59e0b"/><text x="8" y="12" text-anchor="middle" font-size="10" fill="white" font-weight="bold">?!</text></svg>';
      case 'mistake':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#f97316"/><text x="8" y="12" text-anchor="middle" font-size="11" fill="white" font-weight="bold">?</text></svg>';
      case 'blunder':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#ef4444"/><text x="8" y="11" text-anchor="middle" font-size="9" fill="white" font-weight="bold">??</text></svg>';
      case 'brilliant':
        return '<svg width="16" height="16"><defs><linearGradient id="bg"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#f59e0b"/></linearGradient></defs><circle cx="8" cy="8" r="7" fill="url(#bg)"/><text x="8" y="12" text-anchor="middle" font-size="11" fill="white">⭐</text></svg>';
      case 'book':
        return '<svg width="16" height="16"><rect width="16" height="16" rx="3" fill="#6366f1"/><text x="8" y="12" text-anchor="middle" font-size="11" fill="white">📖</text></svg>';
      default:
        return '';
    }
  }

  // ========================
  // UI Updates
  // ========================
  function updatePGNTable() {
    var tbody = document.getElementById('pgnTableBody');
    tbody.innerHTML = '';
    
    if (moveHistory.length === 0) {
      tbody.innerHTML = '<tr><td colspan="3" style="text-align:center; color:#888;">No moves yet</td></tr>';
      return;
    }
    
    for (var i = 0; i < moveHistory.length; i += 2) {
      var row = document.createElement('tr');
      var moveNum = Math.floor(i / 2) + 1;
      
      var numCell = document.createElement('td');
      numCell.className = 'move-number';
      numCell.textContent = moveNum + '.';
      row.appendChild(numCell);
      
      // White move
      var whiteCell = document.createElement('td');
      whiteCell.className = 'move-cell';
      whiteCell.dataset.index = i;
      var whiteText = document.createElement('span');
      whiteText.className = 'move-text';
      whiteText.textContent = moveHistory[i].san;
      whiteCell.appendChild(whiteText);
      
      if (analysisData[i]) {
        var whiteIcon = document.createElement('span');
        whiteIcon.className = 'move-icon';
        whiteIcon.innerHTML = getMoveIcon(analysisData[i].classification);
        whiteCell.appendChild(whiteIcon);
      }
      
      if (i === currentMoveIndex) whiteCell.classList.add('current');
      whiteCell.onclick = function() { goToMove(parseInt(this.dataset.index)); };
      row.appendChild(whiteCell);
      
      // Black move
      var blackCell = document.createElement('td');
      if (i + 1 < moveHistory.length) {
        blackCell.className = 'move-cell';
        blackCell.dataset.index = i + 1;
        var blackText = document.createElement('span');
        blackText.className = 'move-text';
        blackText.textContent = moveHistory[i + 1].san;
        blackCell.appendChild(blackText);
        
        if (analysisData[i + 1]) {
          var blackIcon = document.createElement('span');
          blackIcon.className = 'move-icon';
          blackIcon.innerHTML = getMoveIcon(analysisData[i + 1].classification);
          blackCell.appendChild(blackIcon);
        }
        
        if (i + 1 === currentMoveIndex) blackCell.classList.add('current');
        blackCell.onclick = function() { goToMove(parseInt(this.dataset.index)); };
      }
      row.appendChild(blackCell);
      
      tbody.appendChild(row);
    }
  }

  function updateEvalBar(evaluation) {
    var evalBar = document.getElementById('evalBar');
    var evalBarBlack = document.getElementById('evalBarBlack');
    var evalNumber = document.getElementById('evalNumber');
    
    var clampedEval = Math.max(-1000, Math.min(1000, evaluation));
    var percentage = 50 + (clampedEval / 20);
    percentage = Math.max(0, Math.min(100, percentage));
    
    evalBar.style.height = percentage + '%';
    evalBarBlack.style.height = (100 - percentage) + '%';
    
    var displayEval = (evaluation / 100).toFixed(1);
    if (evaluation > 0) {
      evalNumber.textContent = '+' + displayEval;
    } else if (evaluation < 0) {
      evalNumber.textContent = displayEval;
    } else {
      evalNumber.textContent = '0.0';
    }
    
    if (Math.abs(evaluation) >= 10000) {
      var mateIn = Math.abs(evaluation) - 10000;
      evalNumber.textContent = (evaluation > 0 ? '+M' : '-M') + mateIn;
      evalBar.style.height = evaluation > 0 ? '100%' : '0%';
      evalBarBlack.style.height = evaluation > 0 ? '0%' : '100%';
    }
  }

  function goToMove(index) {
    currentMoveIndex = index;
    
    game.reset();
    for (var i = 0; i <= index; i++) {
      game.move(moveHistory[i]);
    }
    
    board.position(game.fen());
    updatePGNTable();
    
    if (analysisData[index]) {
      updateEvalBar(analysisData[index].currEval);
    }
  }

  // ========================
  // PGN Import
  // ========================
  function parsePGN(pgnText) {
    var lines = pgnText.split('\n');
    var metadata = {};
    var moveText = '';
    
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i].trim();
      if (line.startsWith('[')) {
        var match = line.match(/\[(\w+)\s+"(.+?)"\]/);
        if (match) {
          metadata[match[1].toLowerCase()] = match[2];
        }
      } else if (line.length > 0 && !line.startsWith('[')) {
        moveText += line + ' ';
      }
    }
    
    moveText = moveText.replace(/\{[^}]*\}/g, '');
    moveText = moveText.replace(/\([^)]*\)/g, '');
    moveText = moveText.replace(/[!?]+/g, '');
    moveText = moveText.replace(/\d+-\d+/g, '');
    moveText = moveText.replace(/\d+\./g, '');
    
    var moves = moveText.trim().split(/\s+/).filter(function(m) { return m.length > 0; });
    
    return { metadata: metadata, moves: moves };
  }

  function loadPGN(pgnText) {
    try {
      var parsed = parsePGN(pgnText);
      
      game.reset();
      moveHistory = [];
      currentMoveIndex = -1;
      analysisData = {};
      analysisQueue = [];
      
      gameMetadata = {
        white: parsed.metadata.white || 'White',
        black: parsed.metadata.black || 'Black',
        whiteElo: parsed.metadata.whiteelo || '',
        blackElo: parsed.metadata.blackelo || '',
        event: parsed.metadata.event || '',
        date: parsed.metadata.date || ''
      };
      
      var whiteText = gameMetadata.white;
      if (gameMetadata.whiteElo) whiteText += ' <span class="player-elo">(' + gameMetadata.whiteElo + ')</span>';
      document.getElementById('whitePlayer').innerHTML = '<span class="player-name">' + whiteText + '</span>';
      
      var blackText = gameMetadata.black;
      if (gameMetadata.blackElo) blackText += ' <span class="player-elo">(' + gameMetadata.blackElo + ')</span>';
      document.getElementById('blackPlayer').innerHTML = '<span class="player-name">' + blackText + '</span>';
      
      for (var i = 0; i < parsed.moves.length; i++) {
        var move = game.move(parsed.moves[i]);
        if (move) {
          moveHistory.push(move);
        } else {
          console.warn('Invalid move:', parsed.moves[i]);
          break;
        }
      }
      
      currentMoveIndex = moveHistory.length - 1;
      board.position(game.fen());
      updatePGNTable();
      updateEvalBar(0);
      
      document.getElementById('statusBar').textContent = 'PGN loaded: ' + moveHistory.length + ' moves. Click Analyze to start.';
      document.getElementById('pgnModal').style.display = 'none';
      
    } catch (e) {
      alert('Error parsing PGN: ' + e.message);
      console.error(e);
    }
  }

  // ========================
  // Controls
  // ========================
  document.getElementById('firstBtn').onclick = function() {
    if (moveHistory.length === 0) return;
    game.reset();
    board.position('start');
    currentMoveIndex = -1;
    updatePGNTable();
    updateEvalBar(0);
  };

  document.getElementById('prevBtn').onclick = function() {
    if (currentMoveIndex < 0) return;
    currentMoveIndex--;
    
    game.reset();
    for (var i = 0; i <= currentMoveIndex; i++) {
      game.move(moveHistory[i]);
    }
    
    board.position(game.fen());
    updatePGNTable();
    
    if (currentMoveIndex >= 0 && analysisData[currentMoveIndex]) {
      updateEvalBar(analysisData[currentMoveIndex].currEval);
    } else {
      updateEvalBar(0);
    }
  };

  document.getElementById('nextBtn').onclick = function() {
    if (currentMoveIndex >= moveHistory.length - 1) return;
    currentMoveIndex++;
    
    game.move(moveHistory[currentMoveIndex]);
    board.position(game.fen());
    updatePGNTable();
    
    if (analysisData[currentMoveIndex]) {
      updateEvalBar(analysisData[currentMoveIndex].currEval);
    }
  };

  document.getElementById('lastBtn').onclick = function() {
    if (moveHistory.length === 0) return;
    currentMoveIndex = moveHistory.length - 1;
    
    game.reset();
    for (var i = 0; i <= currentMoveIndex; i++) {
      game.move(moveHistory[i]);
    }
    
    board.position(game.fen());
    updatePGNTable();
    
    if (analysisData[currentMoveIndex]) {
      updateEvalBar(analysisData[currentMoveIndex].currEval);
    }
  };

  document.getElementById('flipBtn').onclick = function() {
    board.flip();
  };

  // Scroll Lock Toggle
  document.getElementById('lockScrollBtn').onclick = function() {
    scrollLocked = !scrollLocked;
    if (scrollLocked) {
      document.body.classList.add('scroll-locked');
      this.classList.add('toggle-active');
      document.getElementById('statusBar').textContent = 'Scroll locked - easier mobile dragging';
    } else {
      document.body.classList.remove('scroll-locked');
      this.classList.remove('toggle-active');
      document.getElementById('statusBar').textContent = 'Scroll unlocked';
    }
  };

  document.getElementById('analyzeBtn').onclick = async function() {
    if (moveHistory.length === 0) {
      alert('No moves to analyze!');
      return;
    }
    
    if (!engineReady) {
      alert('Engine not ready yet. Please wait...');
      return;
    }
    
    var btn = this;
    btn.disabled = true;
    
    document.getElementById('statusBar').innerHTML = '<span class="analyzing">Analyzing all moves...</span>';
    var progressFill = document.getElementById('progressFill');
    
    for (var i = 0; i < moveHistory.length; i++) {
      if (!analysisData[i]) {
        try {
          await analyzeMove(i);
          var progress = ((i + 1) / moveHistory.length) * 100;
          progressFill.style.width = progress + '%';
        } catch (e) {
          console.error('Error analyzing move', i, ':', e);
        }
      }
    }
    
    progressFill.style.width = '0%';
    document.getElementById('statusBar').textContent = 'Full analysis complete! Check move icons.';
    updatePGNTable();
    btn.disabled = false;
  };

  // ========================
  // Modals
  // ========================
  var infoModal = document.getElementById('infoModal');
  var pgnModal = document.getElementById('pgnModal');
  
  document.getElementById('infoBtn').onclick = function() {
    infoModal.style.display = 'block';
  };
  
  document.getElementById('closeModal').onclick = function() {
    infoModal.style.display = 'none';
  };
  
  document.getElementById('pgnInputBtn').onclick = function() {
    pgnModal.style.display = 'block';
  };
  
  document.getElementById('closePgnModal').onclick = function() {
    pgnModal.style.display = 'none';
  };
  
  document.getElementById('submitPgn').onclick = function() {
    var pgnText = document.getElementById('pgnInput').value;
    if (pgnText.trim()) {
      loadPGN(pgnText);
    }
  };
  
  window.onclick = function(event) {
    if (event.target == infoModal) {
      infoModal.style.display = 'none';
    }
    if (event.target == pgnModal) {
      pgnModal.style.display = 'none';
    }
  };

  // ========================
  // Sound
  // ========================
  function playSound(type) {
    var el = null;
    if (type === 'move') el = document.getElementById('moveSound');
    else if (type === 'capture') el = document.getElementById('captureSound');
    
    if (el) {
      el.currentTime = 0;
      el.play().catch(() => {});
    }
  }
  
  </script>
</body>
  </html>
