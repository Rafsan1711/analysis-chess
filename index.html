<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chess Bot + Stockfish — Chessground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- chessground CSS (CDN) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessground/9.2.1/chessground.min.css" />

  <style>
    /* ---------- overall ---------- */
    body { background:#fafafa; font-family: system-ui, Arial, sans-serif; margin:0; padding:0; }
    .app {
      display:flex;
      justify-content:center;
      align-items:flex-start;
      gap:16px;
      padding:20px;
      box-sizing:border-box;
    }

    /* ---------- eval bar (left vertical) ---------- */
    .eval-bar {
      width:36px;              /* fixed width so it stays vertical */
      height:460px;            /* default - responsive changed below */
      background:linear-gradient(#e6e6e6,#ddd);
      border-radius:10px;
      box-shadow:0 2px 6px rgba(0,0,0,0.08);
      position:relative;
      overflow:hidden;
      flex-shrink:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:6px;
    }
    .eval-fill {
      position:absolute;
      left:6px; right:6px;
      bottom:6px;
      border-radius:8px;
      background: linear-gradient(0deg, #1a1a1a 0%, #cfcfcf 100%); /* will be masked by transform to reflect advantage */
      transform-origin: bottom;
      height:50%;
      transition:height 0.25s ease;
      box-shadow:inset 0 -10px 20px rgba(0,0,0,0.12);
    }
    .eval-label {
      position:absolute;
      top:6px;
      width:100%;
      text-align:center;
      font-size:11px;
      color:#333;
      pointer-events:none;
    }

    /* ---------- board + engine status + PGN ---------- */
    .main-col {
      width:420px;
      max-width: calc(100vw - 120px);
    }
    #boardContainer {
      width:100%;
      aspect-ratio:1/1; /* keeps square */
      border-radius:10px;
      overflow:hidden;
      box-shadow:0 6px 18px rgba(0,0,0,0.06);
      background:white;
    }
    #engineStatus { font-size:13px; color:#333; margin-top:8px; }

    /* PGN table */
    .pgn-box {
      margin-top:12px;
      background:#fff;
      border-radius:10px;
      padding:10px;
      box-shadow:0 4px 12px rgba(0,0,0,0.04);
      max-height:190px;
      overflow:auto;
    }
    .pgn-grid {
      display:grid;
      grid-template-columns: 40px 1fr 1fr;
      gap:6px 10px;
      align-items:center;
      font-family:monospace;
      font-size:14px;
    }
    .pgn-movenum { color:#666; text-align:right; padding-right:6px; }
    .pgn-move { padding:6px 8px; border-radius:6px; }
    .pgn-move.w { background:#f7fbff; color:#072a61; }
    .pgn-move.b { background:#fff7fb; color:#610707; }
    .pgn-row:hover .pgn-move { box-shadow:0 2px 6px rgba(0,0,0,0.06); transform:translateY(-2px); transition:all .12s ease; cursor:pointer; }

    /* responsiveness: ensure eval bar remains vertical even on small screens */
    @media (max-width:720px) {
      .app { padding:12px; gap:10px; align-items:flex-start; }
      .eval-bar { height:60vw; width:14vw; min-width:34px; }
      .main-col { width:60vw; max-width: calc(100vw - 80px); }
      .pgn-grid { font-size:13px; }
    }

    /* small utility highlight class for move animation */
    .square-flash {
      box-shadow:0 0 18px 6px rgba(51,221,51,0.12) inset;
      animation: flashit .38s;
    }
    @keyframes flashit {
      from { box-shadow:0 0 18px 8px rgba(51,221,51,0.18) inset; }
      to { box-shadow:none; }
    }

  </style>
</head>
<body>
  <div class="app">
    <!-- left vertical evaluation bar -->
    <div class="eval-bar" aria-hidden="true">
      <div class="eval-label" id="evalLabel">=</div>
      <div class="eval-fill" id="evalFill" style="height:50%;"></div>
    </div>

    <!-- main column: board + status + PGN -->
    <div class="main-col">
      <div id="boardContainer">
        <div id="myBoard" style="width:100%; height:100%;"></div>
      </div>
      <div id="engineStatus">Engine: initializing...</div>

      <div class="pgn-box" aria-live="polite">
        <div class="pgn-grid" id="pgnGrid">
          <!-- grid content populated dynamically -->
        </div>
      </div>
    </div>
  </div>

  <!-- Sounds (same filenames as your original) -->
  <audio id="moveSound" src="sounds/move.mp3"></audio>
  <audio id="captureSound" src="sounds/capture.mp3"></audio>
  <audio id="promoteSound" src="sounds/promote.mp3"></audio>
  <audio id="castlingSound" src="sounds/castling.mp3"></audio>
  <audio id="incorrectMoveSound" src="sounds/incorrect-move.mp3"></audio>
  <audio id="checkSound" src="sounds/check.mp3"></audio>
  <audio id="checkmateSound" src="sounds/checkmate.mp3"></audio>

  <!-- libs: chessground + chess.js (CDN) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessground/9.2.1/chessground.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.4/chess.min.js"></script>

  <!-- keep your piece resolver & engine code mostly unchanged, adapted to chessground -->
  <script>
  // -------------------------
  // piece resolver (unchanged logic)
  // -------------------------
  var pieceCandidates = {
    'wK':['pieces/wK.svg','pieces/wKing.svg','pieces/WK.svg'],
    'wQ':['pieces/wQ.svg','pieces/wQueen.svg','pieces/WQ.svg'],
    'wR':['pieces/wR.svg','pieces/wRook.svg','pieces/WR.svg'],
    'wB':['pieces/wB.svg','pieces/wBishop.svg','pieces/WB.svg'],
    'wN':['pieces/wN.svg','pieces/wKnight.svg','pieces/WN.svg','pieces/wn.svg'],
    'wP':['pieces/wP.svg','pieces/wPawn.svg','pieces/WP.svg'],
    'bK':['pieces/bK.svg','pieces/bKing.svg','pieces/BK.svg'],
    'bQ':['pieces/bQ.svg','pieces/bQueen.svg','pieces/BQ.svg'],
    'bR':['pieces/bR.svg','pieces/bRook.svg','pieces/BR.svg'],
    'bB':['pieces/bB.svg','pieces/bBishop.svg','pieces/BB.svg'],
    'bN':['pieces/bN.svg','pieces/bKnight.svg','pieces/BN.svg','pieces/bn.svg','pieces/black-knight.svg'],
    'bP':['pieces/bP.svg','pieces/bPawn.svg','pieces/BP.svg']
  };
  var pieceImgResolved = {};

  function loadImage(url){ return new Promise(function(resolve,reject){
    var img=new Image();
    img.onload=function(){resolve(url)};
    img.onerror=function(){reject(url)};
    img.src=url;
  }); }

  async function resolvePiece(key, candidates){
    for (var i=0;i<candidates.length;i++){
      try{ var ok = await loadImage(candidates[i]); console.log('Loaded piece', key, '->', candidates[i]); return candidates[i]; }
      catch(e){}
    }
    console.warn('No image found for', key, candidates);
    return null;
  }

  async function resolveAllPieces(){
    var keys=Object.keys(pieceCandidates);
    for (var i=0;i<keys.length;i++){
      pieceImgResolved[keys[i]] = await resolvePiece(keys[i], pieceCandidates[keys[i]]);
    }
    // ensure bN fallback etc.
    if (!pieceImgResolved['bN']) {
      if (pieceImgResolved['wN']) pieceImgResolved['bN'] = pieceImgResolved['wN'];
      else { for (var p in pieceImgResolved) if (pieceImgResolved[p]) { pieceImgResolved['bN'] = pieceImgResolved[p]; break; } }
    }
    var defaultAny=null;
    for (var k in pieceImgResolved) if (pieceImgResolved[k]) { defaultAny = pieceImgResolved[k]; break; }
    for (var k2 in pieceImgResolved) if (!pieceImgResolved[k2]) pieceImgResolved[k2] = defaultAny;
    console.log('Resolved pieces:', pieceImgResolved);
    return pieceImgResolved;
  }

  // -------------------------
  // chess game + engine state
  // -------------------------
  var game = new Chess();         // chess.js
  var globalSum = 0;             // evaluation accumulator used by minimax evaluator

  var aiMode = 'stockfish';      // 'stockfish' or 'minimax'
  var stockfishEngine = null;
  var engineReady = false;
  var engineBusy = false;
  var stockfishMovetime = 800;
  var engineOpts = {};
  var engineDefaultHandler = null;

  // re-entrancy & input guards
  var inputLocked = false;
  var processingMove = false;

  function computeEngineOptions(){
    var hwc = navigator.hardwareConcurrency || 2;
    var isMobile = /Mobi|Android/i.test(navigator.userAgent) || (window.innerWidth && window.innerWidth < 720);
    var threads = isMobile ? 1 : Math.min(4, Math.max(1, Math.floor(hwc)));
    var hash = isMobile ? 16 : 64;
    var movetime = isMobile ? 350 : (hwc >= 8 ? 1200 : 800);
    var skill = 20;
    engineOpts = {threads:threads, hash:hash, movetime:movetime, skill:skill, isMobile:isMobile, hwc:hwc};
    stockfishMovetime = movetime;
    return engineOpts;
  }

  function createStockfishBlobWorker(cdnUrl) {
    try {
      var blobCode = "importScripts('" + cdnUrl + "');";
      var blob = new Blob([blobCode], {type: 'application/javascript'});
      var blobURL = URL.createObjectURL(blob);
      var w = new Worker(blobURL);
      setTimeout(function(){ URL.revokeObjectURL(blobURL); }, 5000);
      return w;
    } catch (e) {
      console.error('createStockfishBlobWorker failed', e);
      return null;
    }
  }

  function textFromEvent(ev) {
    var d = (ev && ev.data !== undefined) ? ev.data : ev;
    if (typeof d === 'string') return d;
    try { return '' + d; } catch(e){ return String(d); }
  }

  function initStockfish() {
    var opts = computeEngineOptions();
    console.log('Engine options:', opts);
    document.getElementById('engineStatus').innerText = 'Engine: loading...';

    try {
      if (typeof STOCKFISH === 'function') {
        stockfishEngine = STOCKFISH();
      } else {
        // default cdn; you can replace with a local path if you downloaded stockfish.js
        var cdn = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
        stockfishEngine = createStockfishBlobWorker(cdn);
      }
    } catch (e) {
      console.warn('Stockfish init attempt failed:', e);
      stockfishEngine = null;
    }

    if (!stockfishEngine) {
      engineReady = false;
      document.getElementById('engineStatus').innerText = 'Engine: unavailable (fallback to minimax)';
      console.warn('Stockfish not available; using minimax fallback.');
      return;
    }

    // default handler: watch for readyok
    engineDefaultHandler = function(ev) {
      var line = textFromEvent(ev).trim();
      if (!line) return;
      console.log('stockfish:', line);
      if (line.indexOf('readyok') !== -1) {
        engineReady = true;
        document.getElementById('engineStatus').innerText =
          'Engine: ready (Stockfish, threads ' + engineOpts.threads + ', hash ' + engineOpts.hash + 'MB)';
      }
    };

    try {
      stockfishEngine.onmessage = engineDefaultHandler;
      stockfishEngine.postMessage('uci');
      stockfishEngine.postMessage('setoption name Threads value ' + (engineOpts.threads || computeEngineOptions().threads));
      stockfishEngine.postMessage('setoption name Hash value ' + (engineOpts.hash || computeEngineOptions().hash));
      stockfishEngine.postMessage('setoption name Skill Level value ' + (engineOpts.skill || computeEngineOptions().skill));
      stockfishEngine.postMessage('setoption name UCI_LimitStrength value false');
      stockfishEngine.postMessage('isready');
    } catch (e) {
      console.error('Error configuring stockfish:', e);
    }
  }

  // Safe SF query: capture both info lines (for evaluation bar) and bestmove, restore handler always
  function stockfishBestMove(fen, movetimeMs) {
    return new Promise(function(resolve, reject) {
      if (!stockfishEngine || !engineReady) return reject('engine not ready');
      if (engineBusy) return reject('engine busy');
      engineBusy = true;

      var prevHandler = stockfishEngine.onmessage;
      var timeoutId = null;

      var capture = function(ev) {
        var line = textFromEvent(ev).trim();
        if (!line) return;
        // forward info cp/mate for live eval bar
        if (line.indexOf('info') === 0 && (line.indexOf('score cp') !== -1 || line.indexOf('score mate') !== -1)) {
          // attempt to parse cp or mate
          var m_cp = line.match(/score cp (-?\d+)/);
          var m_mate = line.match(/score mate (-?\d+)/);
          if (m_cp) {
            var cp = parseInt(m_cp[1],10);
            try { updateEvalFromCP(cp); } catch(e){}
          } else if (m_mate) {
            // large advantage when mate in N (positive => white), convert to cp-like scale
            var mate = parseInt(m_mate[1],10);
            var cpApprox = mate > 0 ? 10000 - mate : -10000 - mate;
            try { updateEvalFromCP(cpApprox); } catch(e){}
          }
        }

        if (line.indexOf('bestmove') === 0) {
          try {
            var parts = line.split(/\s+/);
            var best = parts[1];
            try { stockfishEngine.onmessage = prevHandler; } catch(e) {}
            if (timeoutId) clearTimeout(timeoutId);
            engineBusy = false;
            resolve(best);
          } catch (err) {
            try { stockfishEngine.onmessage = prevHandler; } catch(e) {}
            if (timeoutId) clearTimeout(timeoutId);
            engineBusy = false;
            reject(err);
          }
        }
      };

      try {
        stockfishEngine.onmessage = capture;
        stockfishEngine.postMessage('position fen ' + fen);
        stockfishEngine.postMessage('go movetime ' + parseInt(movetimeMs,10));
      } catch (e) {
        try { stockfishEngine.onmessage = prevHandler; } catch(ignore) {}
        engineBusy = false;
        return reject(e);
      }

      // safety timeout (forces fallback)
      timeoutId = setTimeout(function() {
        try { stockfishEngine.onmessage = prevHandler; } catch(e) {}
        engineBusy = false;
        reject('timeout');
      }, Math.max(8000, movetimeMs + 4000));
    });
  }

  // -------------------------
  // minimax fallback (kept)
  // -------------------------
  var weights = { p:100,n:280,b:320,r:479,q:929,k:60000,k_e:60000 };
  var pst_w = {
    p: [[100,100,100,100,105,100,100,100],[78,83,86,73,102,82,85,90],[7,29,21,44,40,31,44,7],[-17,16,-2,15,14,0,15,-13],[-26,3,10,9,6,1,0,-23],[-22,9,5,-11,-10,-2,3,-19],[-31,8,-7,-37,-36,-14,3,-31],[0,0,0,0,0,0,0,0]],
    n: [[-66,-53,-75,-75,-10,-55,-58,-70],[-3,-6,100,-36,4,62,-4,-14],[10,67,1,74,73,27,62,-2],[24,24,45,37,33,41,25,17],[-1,5,31,21,22,35,2,0],[-18,10,13,22,18,15,11,-14],[-23,-15,2,0,2,0,-23,-20],[-74,-23,-26,-24,-19,-35,-22,-69]],
    b: [[-59,-78,-82,-76,-23,-107,-37,-50],[-11,20,35,-42,-39,31,2,-22],[-9,39,-32,41,52,-10,28,-14],[25,17,20,34,26,25,15,10],[13,10,17,23,17,16,0,7],[14,25,24,15,8,25,20,15],[19,20,11,6,7,6,20,16],[-7,2,-15,-12,-14,-15,-10,-10]],
    r: [[35,29,33,4,37,33,56,50],[55,29,56,67,55,62,34,60],[19,35,28,33,45,27,25,15],[0,5,16,13,18,-4,-9,-6],[-28,-35,-16,-21,-13,-29,-46,-30],[-42,-28,-42,-25,-25,-35,-26,-46],[-53,-38,-31,-26,-29,-43,-44,-53],[-30,-24,-18,5,-2,-18,-31,-32]],
    q: [[6,1,-8,-104,69,24,88,26],[14,32,60,-10,20,76,57,24],[-2,43,32,60,72,63,43,2],[1,-16,22,17,25,20,-13,-6],[-14,-15,-2,-5,-1,-10,-20,-22],[-30,-6,-13,-11,-16,-11,-16,-27],[-36,-18,0,-19,-15,-15,-21,-38],[-39,-30,-31,-13,-31,-36,-34,-42]],
    k: [[4,54,47,-99,-99,60,83,-62],[-32,10,55,56,56,55,10,3],[-62,12,-57,44,-67,28,37,-31],[-55,50,11,-4,-19,13,0,-49],[-55,-43,-52,-28,-51,-47,-8,-50],[-47,-42,-43,-79,-64,-32,-29,-32],[-4,3,-14,-50,-57,-18,13,4],[17,30,-3,-14,6,-1,40,18]],
    k_e: [[-50,-40,-30,-20,-20,-30,-40,-50],[-30,-20,-10,0,0,-10,-20,-30],[-30,-10,20,30,30,20,-10,-30],[-30,-10,30,40,40,30,-10,-30],[-30,-10,30,40,40,30,-10,-30],[-30,-10,20,30,30,20,-10,-30],[-30,-30,0,0,0,0,-30,-30],[-50,-30,-30,-30,-30,-30,-30,-50]]
  };
  var pst_b = { p: pst_w['p'].slice().reverse(), n: pst_w['n'].slice().reverse(), b: pst_w['b'].slice().reverse(), r: pst_w['r'].slice().reverse(), q: pst_w['q'].slice().reverse(), k: pst_w['k'].slice().reverse(), k_e: pst_w['k_e'].slice().reverse() };
  var pstOpponent = { w: pst_b, b: pst_w };
  var pstSelf = { w: pst_w, b: pst_b };

  function evaluateBoard(game, move, prevSum, color) {
    if (game.in_checkmate()) { if (move.color === color) return 1e10; else return -1e10; }
    if (game.in_draw() || game.in_threefold_repetition() || game.in_stalemate()) return 0;
    if (game.in_check()) { if (move.color === color) prevSum += 50; else prevSum -= 50; }
    var from = [8 - parseInt(move.from[1]), move.from.charCodeAt(0) - 'a'.charCodeAt(0)];
    var to = [8 - parseInt(move.to[1]), move.to.charCodeAt(0) - 'a'.charCodeAt(0)];
    if (prevSum < -1500 && move.piece === 'k') move.piece = 'k_e';
    if ('captured' in move) {
      if (move.color === color) prevSum += weights[move.captured] + pstOpponent[move.color][move.captured][to[0]][to[1]];
      else prevSum -= weights[move.captured] + pstSelf[move.color][move.captured][to[0]][to[1]];
    }
    if (move.flags && move.flags.includes('p')) {
      move.promotion = 'q';
      if (move.color === color) {
        prevSum -= weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum += weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]];
      } else {
        prevSum += weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum -= weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]];
      }
    } else {
      if (move.color !== color) {
        prevSum += pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum -= pstSelf[move.color][move.piece][to[0]][to[1]];
      } else {
        prevSum -= pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum += pstSelf[move.color][move.piece][to[0]][to[1]];
      }
    }
    return prevSum;
  }

  function minimax(game, depth, alpha, beta, isMax, sum, color) {
    var children = game.ugly_moves({ verbose: true });
    children.sort(function(){ return 0.5 - Math.random(); });
    if (depth === 0 || children.length === 0) return [null, sum];
    var maxV = Number.NEGATIVE_INFINITY, minV = Number.POSITIVE_INFINITY, best = null;
    for (var i=0;i<children.length;i++){
      var m = children[i];
      var pm = game.ugly_move(m);
      var newSum = evaluateBoard(game, pm, sum, color);
      var [, childVal] = minimax(game, depth-1, alpha, beta, !isMax, newSum, color);
      game.undo();
      if (isMax) {
        if (childVal > maxV) { maxV = childVal; best = pm; }
        if (childVal > alpha) alpha = childVal;
      } else {
        if (childVal < minV) { minV = childVal; best = pm; }
        if (childVal < beta) beta = childVal;
      }
      if (alpha >= beta) break;
    }
    return isMax ? [best, maxV] : [best, minV];
  }
  function getBestMoveMinimax(game, color, currSum) {
    var depth = 2;
    return minimax(game, depth, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, true, currSum, color)[0];
  }

  // -------------------------
  // UI / chessground init
  // -------------------------
  var cg = null;            // chessground instance
  var defaultPieceUrl = null;
  (async function init() {
    try { await resolveAllPieces(); } catch(e){ console.error('resolve pieces failed', e); }
    initStockfish();

    // pick some default piece if some were missing
    for (var k in pieceImgResolved) { if (pieceImgResolved[k]) { defaultPieceUrl = pieceImgResolved[k]; break; } }

    // pieceTheme for chessground: expects function(piece) -> url
    function pieceTheme(p) {
      // chessground piece code like 'wK' or 'bP' (this should match our keys)
      if (pieceImgResolved && pieceImgResolved[p]) return pieceImgResolved[p];
      // try normalized
      var norm = p.replace(/([wb])([prnbqkPRNBQK])/,'$1$2');
      if (pieceImgResolved[norm]) return pieceImgResolved[norm];
      return defaultPieceUrl;
    }

    // initialize chessground
    cg = Chessground(document.getElementById('myBoard'), {
      fen: game.fen(),
      orientation: 'white',
      movable: {
        free: false,
        color: 'white',
        // show destinations when dragging
        dests: null,
        events: {
          // called after a legal move was made on the board (orig and dest are in algebraic like 'e2','e4')
          after: function(orig, dest, metadata) {
            // guard while engine/bot is processing
            if (inputLocked) {
              // revert if input locked
              cg.set({fen: game.fen()});
              return;
            }

            // try to make the move in chess.js
            var move = game.move({from: orig, to: dest, promotion: 'q'});
            if (move === null) {
              // illegal move, revert board
              playSound('incorrect');
              cg.set({fen: game.fen()});
              return;
            }

            // play effects locally for user move
            playMoveEffectAndSound(move);
            flashSquare(orig);
            flashSquare(dest);

            // lock input and run doMoveLogic (which will apply engine move)
            inputLocked = true;
            doMoveLogic(move, orig, dest, true);
          }
        }
      },
      animation: { enabled: true, duration: 240 },
      highlight: { lastMove: true, check: true },
      drawable: { enabled: false },
      movableColor: 'white',
      // custom piece theme
      pieceTheme: pieceTheme
    });

    // ensure css transitions for pieces are smooth
    setTimeout(function(){
      var el = document.querySelector('#myBoard');
      if (el) el.style.transition = 'transform 0.18s ease';
    }, 200);
    updatePGN(); // initial PGN (empty)
    updateEvalLabel(0); // neutral start
  })();

  // ---------- visuals helpers ----------
  function flashSquare(square) {
    try {
      // chessground squares have data-square attribute on .cg-square elements
      var q = document.querySelector('#myBoard .cg-board [data-square="' + square + '"]');
      if (!q) q = document.querySelector('#myBoard [data-square="' + square + '"]');
      if (!q) return;
      q.classList.add('square-flash');
      setTimeout(function(){ q.classList.remove('square-flash'); }, 380);
    } catch (e) {}
  }

  // -------------------------
  // sounds/effects/move logic (kept)
  // -------------------------
  function playSound(type) {
    var el=null;
    switch(type){
      case 'move': el=document.getElementById('moveSound'); break;
      case 'capture': el=document.getElementById('captureSound'); break;
      case 'promote': el=document.getElementById('promoteSound'); break;
      case 'castling': el=document.getElementById('castlingSound'); break;
      case 'incorrect': el=document.getElementById('incorrectMoveSound'); break;
      case 'check': el=document.getElementById('checkSound'); break;
      case 'checkmate': el=document.getElementById('checkmateSound'); break;
    }
    if (el) { el.currentTime = 0; el.play().catch(()=>{}); }
  }

  function playMoveEffectAndSound(move) {
    if (move.flags && (move.flags.includes('k') || move.flags.includes('q'))) playSound('castling');
    else if (move.flags && move.flags.includes('p')) playSound('promote');
    else if (move.flags && (move.flags.includes('c') || move.flags.includes('e'))) playSound('capture');
    else playSound('move');
    if (game.in_checkmate()) playSound('checkmate');
    else if (game.in_check()) playSound('check');
  }

  // core: robust doMoveLogic with locks and guaranteed unlock (adapted to chessground)
  async function doMoveLogic(move, source, target, isDrag) {
    if (processingMove) { console.warn('doMoveLogic re-entry blocked'); return; }
    processingMove = true;
    try {
      // already did visual effects for user's move
      globalSum = evaluateBoard(game, move, globalSum, 'b');

      // allow small delay for UI to settle, then compute bot move
      await new Promise(r => setTimeout(r, 300));

      if (game.game_over() || game.turn() !== 'b') {
        // unlock input (game may be over or not bot's turn)
        inputLocked = false;
        processingMove = false;
        updatePGN();
        // ensure board shows current fen
        cg.set({fen: game.fen()});
        return;
      }

      // prefer stockfish if ready
      if (aiMode === 'stockfish' && stockfishEngine && engineReady) {
        try {
          var fen = game.fen();
          console.log('Requesting SF bestmove for fen:', fen);
          var best = await stockfishBestMove(fen, stockfishMovetime).catch(function(e){ console.warn('SF query failed:', e); return null; });
          console.log('Stockfish answered bestmove:', best);

          if (best && best !== '(none)') {
            var from = best.slice(0,2);
            var to = best.slice(2,4);
            var promotion = (best.length > 4) ? best[4] : null;

            // Validate against legal moves
            var legals = game.moves({ verbose: true });
            var matched = null;
            for (var i = 0; i < legals.length; i++) {
              var m = legals[i];
              if (m.from === from && m.to === to) {
                if (promotion) {
                  if (m.promotion && m.promotion === promotion.toLowerCase()) { matched = m; break; }
                } else { matched = m; break; }
              }
            }

            if (matched) {
              console.log('Applying SF move (validated):', matched);
              var botMove = game.move({ from: matched.from, to: matched.to, promotion: matched.promotion || 'q' });
              if (botMove) {
                playMoveEffectAndSound(botMove);
                flashSquare(botMove.from);
                flashSquare(botMove.to);
                globalSum = evaluateBoard(game, botMove, globalSum, 'b');
                // update board
                cg.set({fen: game.fen()});
                updatePGN();
                inputLocked = false; // unlock after bot move applied
                processingMove = false;
                return;
              } else {
                console.warn('game.move returned null despite matched legal move:', matched);
              }
            } else {
              console.warn('Stockfish suggested move not found in legal moves:', best);
            }
          } else {
            console.warn('Stockfish returned no usable bestmove:', best);
          }
        } catch (e) {
          console.warn('Stockfish error during move apply -> fallback to minimax', e);
        }
      }

      // fallback minimax
      if (!game.game_over() && game.turn() === 'b') {
        var botMove = getBestMoveMinimax(game, 'b', globalSum);
        if (botMove) {
          game.move(botMove);
          playMoveEffectAndSound(botMove);
          flashSquare(botMove.from);
          flashSquare(botMove.to);
          globalSum = evaluateBoard(game, botMove, globalSum, 'b');
          cg.set({fen: game.fen()});
          updatePGN();
        } else {
          console.warn('Minimax did not return move — position may be terminal.');
        }
      }

      // unlock input finally
      inputLocked = false;
    } finally {
      processingMove = false;
    }
  }

  // -------------------------
  // PGN / UI helpers
  // -------------------------
  function updatePGN() {
    var moves = game.history();
    var grid = document.getElementById('pgnGrid');
    grid.innerHTML = '';
    for (var i = 0; i < moves.length; i += 2) {
      var num = Math.floor(i / 2) + 1;
      var white = moves[i] || '';
      var black = moves[i + 1] || '';
      var row = document.createElement('div');
      row.className = 'pgn-row';
      // move number
      var mn = document.createElement('div');
      mn.className = 'pgn-movenum';
      mn.textContent = num + '.';
      grid.appendChild(mn);

      // white
      var wdiv = document.createElement('div');
      wdiv.className = 'pgn-move w';
      wdiv.textContent = white;
      (function(mnum, halfIndex){ wdiv.onclick = function(){ seekToMove(mnum, 'w'); }; })(num, i);
      grid.appendChild(wdiv);

      // black
      var bdiv = document.createElement('div');
      bdiv.className = 'pgn-move b';
      bdiv.textContent = black;
      (function(mnum, halfIndex){ bdiv.onclick = function(){ seekToMove(mnum, 'b'); }; })(num, i+1);
      grid.appendChild(bdiv);
    }
  }

  function seekToMove(moveNumber, color) {
    // reconstruct fen up to the chosen ply
    var history = game.history({ verbose: true });
    // make a new game and apply moves up to desired ply
    var g2 = new Chess();
    var plyIndex = (moveNumber - 1) * 2 + (color === 'b' ? 1 : 0);
    for (var i = 0; i <= plyIndex && i < history.length; i++) {
      var m = history[i];
      g2.move({ from: m.from, to: m.to, promotion: m.promotion || 'q' });
    }
    // set board to that fen
    cg.set({fen: g2.fen()});
  }

  // -------------------------
  // Eval bar helpers
  // -------------------------
  function updateEvalFromCP(cp) {
    // cp >0 means white advantage; scale to percentage 0..100 for eval-fill height
    // Use a soft-scaling so huge CP doesn't saturate entirely immediately
    var clamp = function(v, a, b){ return Math.max(a, Math.min(b, v)); };
    // map cp to -1500..+1500 range
    var capped = clamp(cp, -1500, 1500);
    // convert to fraction: 0 for -1500, 1 for +1500
    var frac = (capped + 1500) / 3000;
    var percent = Math.round(frac * 100);
    // set bar height; white advantage means higher fill (bottom to top)
    var fillEl = document.getElementById('evalFill');
    if (fillEl) fillEl.style.height = percent + '%';
    // label
    updateEvalLabel(cp);
  }

  function updateEvalLabel(cp) {
    var label = document.getElementById('evalLabel');
    if (!label) return;
    if (cp === 0) label.textContent = '=';
    else if (cp > 0) {
      if (cp > 500) label.textContent = '+' + Math.round(cp);
      else label.textContent = '+' + cp;
    } else {
      label.textContent = '' + cp;
    }
  }

  // -------------------------
  // small defensive UI: if user clicks outside board, re-clear highlights (not necessary with chessground)
  // -------------------------
  document.addEventListener('click', function(e){
    // clicking on PGN moves is handled; nothing else needed for chessground
  });

  // -------------------------
  // graceful fallback: if engine not available, allow playing vs minimax only
  // -------------------------
  // engineReady flag set in initStockfish()

  </script>
</body>
    </html>
