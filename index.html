<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chess Analysis Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" crossorigin="anonymous">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #e0e0e0;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }
    
    .board-section {
      display: flex;
      gap: 15px;
      flex: 1;
      min-width: 320px;
    }
    
    /* Evaluation Bar */
    .eval-bar-container {
      width: 50px;
      position: relative;
      background: #2a2a3e;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    
    .eval-bar {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: linear-gradient(to top, #ffffff 0%, #f0f0f0 100%);
      transition: height 0.3s ease;
    }
    
    .eval-number {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      z-index: 10;
      min-width: 40px;
      text-align: center;
    }
    
    /* Board */
    .board-wrapper {
      flex: 1;
      max-width: 500px;
    }
    
    #myBoard { 
      width: 100% !important;
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
      border-radius: 8px;
      overflow: hidden;
    }
    
    /* Controls */
    .controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    
    .controls button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      color: white;
      padding: 10px 18px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);
    }
    
    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(102, 126, 234, 0.5);
    }
    
    .controls button:active {
      transform: translateY(0);
    }
    
    .controls button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }
    
    /* PGN Section */
    .pgn-section {
      flex: 1;
      min-width: 300px;
      background: #2a2a3e;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }
    
    .pgn-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #667eea;
    }
    
    .pgn-header h3 {
      color: #667eea;
      font-size: 18px;
    }
    
    .info-btn {
      background: #667eea;
      border: none;
      color: white;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      transition: all 0.2s;
    }
    
    .info-btn:hover {
      background: #764ba2;
      transform: scale(1.1);
    }
    
    /* PGN Table */
    .pgn-table-container {
      max-height: 500px;
      overflow-y: auto;
      background: #1e1e2e;
      border-radius: 8px;
      padding: 10px;
    }
    
    .pgn-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .pgn-table th {
      background: #667eea;
      color: white;
      padding: 10px;
      text-align: left;
      position: sticky;
      top: 0;
      z-index: 5;
    }
    
    .pgn-table td {
      padding: 8px 10px;
      border-bottom: 1px solid #3a3a4e;
    }
    
    .pgn-table tr:hover {
      background: #3a3a5e;
    }
    
    .pgn-table .move-number {
      color: #888;
      width: 50px;
      text-align: center;
    }
    
    .pgn-table .move-cell {
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .pgn-table .move-cell:hover {
      color: #667eea;
      font-weight: bold;
    }
    
    .pgn-table .move-cell.current {
      background: #667eea;
      color: white;
      font-weight: bold;
    }
    
    .move-text {
      display: inline-block;
      min-width: 60px;
    }
    
    .move-icon {
      float: right;
      margin-left: 8px;
    }
    
    /* Modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(5px);
    }
    
    .modal-content {
      background: #2a2a3e;
      margin: 10% auto;
      padding: 30px;
      border-radius: 12px;
      max-width: 500px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      animation: modalSlideIn 0.3s ease;
    }
    
    @keyframes modalSlideIn {
      from { transform: translateY(-50px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .modal-content h2 {
      color: #667eea;
      margin-bottom: 20px;
    }
    
    .icon-legend {
      display: grid;
      gap: 12px;
    }
    
    .icon-item {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 10px;
      background: #1e1e2e;
      border-radius: 6px;
    }
    
    .icon-item svg {
      flex-shrink: 0;
    }
    
    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: color 0.2s;
    }
    
    .close:hover { color: #667eea; }
    
    /* Status */
    .status-bar {
      text-align: center;
      margin-top: 10px;
      padding: 8px;
      background: #1e1e2e;
      border-radius: 6px;
      font-size: 13px;
      color: #888;
    }
    
    .analyzing {
      color: #667eea;
      font-weight: bold;
    }
    
    /* Scrollbar */
    .pgn-table-container::-webkit-scrollbar {
      width: 8px;
    }
    
    .pgn-table-container::-webkit-scrollbar-track {
      background: #1e1e2e;
      border-radius: 4px;
    }
    
    .pgn-table-container::-webkit-scrollbar-thumb {
      background: #667eea;
      border-radius: 4px;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      
      .board-section {
        width: 100%;
      }
      
      .board-wrapper {
        max-width: calc(100vw - 90px);
      }
      
      .pgn-section {
        width: 100%;
      }
    }
    
    /* Move effects */
    .highlight-square { box-shadow: 0 0 10px 3px rgba(102, 126, 234, 0.6) inset; }
    .last-move { box-shadow: 0 0 8px 2px rgba(255, 215, 0, 0.4) inset; }
  </style>
</head>
<body>
  <div class="container">
    <div class="board-section">
      <div class="eval-bar-container">
        <div class="eval-bar" id="evalBar" style="height: 50%;"></div>
        <div class="eval-number" id="evalNumber">0.0</div>
      </div>
      
      <div class="board-wrapper">
        <div id="myBoard"></div>
        <div class="controls">
          <button id="firstBtn" title="First Move">‚èÆ</button>
          <button id="prevBtn" title="Previous Move">‚óÄ</button>
          <button id="nextBtn" title="Next Move">‚ñ∂</button>
          <button id="lastBtn" title="Last Move">‚è≠</button>
          <button id="flipBtn" title="Flip Board">üîÑ</button>
          <button id="analyzeBtn" title="Analyze Position">üîç</button>
        </div>
        <div class="status-bar" id="statusBar">Ready to analyze</div>
      </div>
    </div>
    
    <div class="pgn-section">
      <div class="pgn-header">
        <h3>Move List</h3>
        <button class="info-btn" id="infoBtn">i</button>
      </div>
      <div class="pgn-table-container">
        <table class="pgn-table">
          <thead>
            <tr>
              <th>#</th>
              <th>White</th>
              <th>Black</th>
            </tr>
          </thead>
          <tbody id="pgnTableBody">
            <tr>
              <td colspan="3" style="text-align:center; color:#888;">No moves yet</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Info Modal -->
  <div id="infoModal" class="modal">
    <div class="modal-content">
      <span class="close" id="closeModal">&times;</span>
      <h2>Move Annotations</h2>
      <div class="icon-legend">
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#4ade80"/><text x="10" y="15" text-anchor="middle" font-size="14" fill="white" font-weight="bold">‚úì</text></svg>
          <div><strong>Best Move</strong> - Engine's top choice</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#22c55e"/><text x="10" y="15" text-anchor="middle" font-size="14" fill="white" font-weight="bold">!</text></svg>
          <div><strong>Great Move</strong> - Excellent, gaining advantage</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#84cc16"/><circle cx="10" cy="10" r="3" fill="white"/></svg>
          <div><strong>Good Move</strong> - Solid, maintaining position</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#f59e0b"/><text x="10" y="15" text-anchor="middle" font-size="12" fill="white" font-weight="bold">?!</text></svg>
          <div><strong>Inaccuracy</strong> - Slight mistake (50-100 cp)</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#f97316"/><text x="10" y="15" text-anchor="middle" font-size="14" fill="white" font-weight="bold">?</text></svg>
          <div><strong>Mistake</strong> - Clear error (100-200 cp)</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#ef4444"/><text x="10" y="15" text-anchor="middle" font-size="12" fill="white" font-weight="bold">??</text></svg>
          <div><strong>Blunder</strong> - Serious mistake (>200 cp)</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><defs><linearGradient id="brilliantGrad"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#f59e0b"/></linearGradient></defs><circle cx="10" cy="10" r="9" fill="url(#brilliantGrad)"/><text x="10" y="15" text-anchor="middle" font-size="14" fill="white">‚≠ê</text></svg>
          <div><strong>Brilliant</strong> - Spectacular move</div>
        </div>
        <div class="icon-item">
          <svg width="20" height="20"><circle cx="10" cy="10" r="9" fill="#3b82f6"/><text x="10" y="15" text-anchor="middle" font-size="12" fill="white" font-weight="bold">!?</text></svg>
          <div><strong>Interesting</strong> - Viable alternative</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Audio -->
  <audio id="moveSound" src="sounds/move.mp3"></audio>
  <audio id="captureSound" src="sounds/capture.mp3"></audio>

  <!-- Scripts -->
  <script src="https://code.jquery.com/jquery-3.5.1.js"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
  <script src="js/chess.js"></script>

  <script>
  // ========================
  // Piece Theme Resolver
  // ========================
  var pieceCandidates = {
    'wK':['pieces/wK.svg','pieces/wKing.svg'], 'wQ':['pieces/wQ.svg','pieces/wQueen.svg'],
    'wR':['pieces/wR.svg','pieces/wRook.svg'], 'wB':['pieces/wB.svg','pieces/wBishop.svg'],
    'wN':['pieces/wN.svg','pieces/wKnight.svg'], 'wP':['pieces/wP.svg','pieces/wPawn.svg'],
    'bK':['pieces/bK.svg','pieces/bKing.svg'], 'bQ':['pieces/bQ.svg','pieces/bQueen.svg'],
    'bR':['pieces/bR.svg','pieces/bRook.svg'], 'bB':['pieces/bB.svg','pieces/bBishop.svg'],
    'bN':['pieces/bN.svg','pieces/bKnight.svg'], 'bP':['pieces/bP.svg','pieces/bPawn.svg']
  };
  var pieceImgResolved = {};

  function loadImage(url){ return new Promise((resolve,reject)=> { var img=new Image(); img.onload=()=>resolve(url); img.onerror=()=>reject(url); img.src=url; }); }
  async function resolvePiece(key, candidates){
    for (var i=0;i<candidates.length;i++){
      try{ return await loadImage(candidates[i]); } catch(e){}
    }
    return null;
  }
  async function resolveAllPieces(){
    for (var key in pieceCandidates) { pieceImgResolved[key] = await resolvePiece(key, pieceCandidates[key]); }
    var defaultAny=null; for (var k in pieceImgResolved) if (pieceImgResolved[k]) { defaultAny = pieceImgResolved[k]; break; }
    for (var k2 in pieceImgResolved) if (!pieceImgResolved[k2]) pieceImgResolved[k2] = defaultAny;
    return pieceImgResolved;
  }

  // ========================
  // Stockfish Engine
  // ========================
  var stockfishEngine = null;
  var engineReady = false;

  function createStockfishBlobWorker(cdnUrl) {
    try {
      var blobCode = "importScripts('" + cdnUrl + "');";
      var blob = new Blob([blobCode], {type: 'application/javascript'});
      var blobURL = URL.createObjectURL(blob);
      return new Worker(blobURL);
    } catch (e) {
      return null;
    }
  }

  function initStockfish() {
    try {
      var cdn = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
      stockfishEngine = createStockfishBlobWorker(cdn);
      
      stockfishEngine.onmessage = function(e) {
        var line = e.data;
        if (line.indexOf('readyok') !== -1) {
          engineReady = true;
          console.log('Stockfish ready');
        }
      };
      
      stockfishEngine.postMessage('uci');
      stockfishEngine.postMessage('setoption name Threads value 2');
      stockfishEngine.postMessage('setoption name Hash value 64');
      stockfishEngine.postMessage('isready');
    } catch (e) {
      console.error('Stockfish init failed:', e);
    }
  }

  function evaluatePosition(fen, depth = 15) {
    return new Promise((resolve, reject) => {
      if (!stockfishEngine || !engineReady) return reject('engine not ready');
      
      var timeout = setTimeout(() => reject('timeout'), 10000);
      
      stockfishEngine.onmessage = function(e) {
        var line = e.data;
        if (line.indexOf('score cp') !== -1) {
          var match = line.match(/score cp (-?\d+)/);
          if (match) {
            clearTimeout(timeout);
            resolve(parseInt(match[1]));
          }
        } else if (line.indexOf('score mate') !== -1) {
          var match = line.match(/score mate (-?\d+)/);
          if (match) {
            clearTimeout(timeout);
            var mateIn = parseInt(match[1]);
            resolve(mateIn > 0 ? 10000 : -10000);
          }
        }
      };
      
      stockfishEngine.postMessage('position fen ' + fen);
      stockfishEngine.postMessage('go depth ' + depth);
    });
  }

  // ========================
  // Game State
  // ========================
  var board = null;
  var game = new Chess();
  var moveHistory = [];
  var currentMoveIndex = -1;
  var analysisData = {};

  // ========================
  // Board Init
  // ========================
  (async function init() {
    await resolveAllPieces();
    initStockfish();

    function pieceTheme(piece) {
      return pieceImgResolved[piece] || pieceImgResolved['wK'];
    }

    var config = {
      draggable: true,
      position: 'start',
      pieceTheme: pieceTheme,
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd
    };
    
    board = Chessboard('myBoard', config);
    
    // Initialize with starting position
    updatePGNTable();
    updateEvalBar(0);
  })();

  function onDragStart(source, piece) {
    if (game.game_over()) return false;
    if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
  }

  function onDrop(source, target) {
    var move = game.move({
      from: source,
      to: target,
      promotion: 'q'
    });

    if (move === null) {
      playSound('move');
      return 'snapback';
    }

    playSound(move.captured ? 'capture' : 'move');
    moveHistory.push(move);
    currentMoveIndex = moveHistory.length - 1;
    updatePGNTable();
    analyzeMove(moveHistory.length - 1);
  }

  function onSnapEnd() {
    board.position(game.fen());
  }

  // ========================
  // Move Analysis
  // ========================
  async function analyzeMove(moveIndex) {
    if (!engineReady) return;
    
    document.getElementById('statusBar').innerHTML = '<span class="analyzing">Analyzing...</span>';
    
    try {
      // Get position before move
      var tempGame = new Chess();
      for (var i = 0; i < moveIndex; i++) {
        tempGame.move(moveHistory[i]);
      }
      var prevFen = tempGame.fen();
      var prevEval = await evaluatePosition(prevFen, 12);
      
      // Get position after move
      tempGame.move(moveHistory[moveIndex]);
      var currFen = tempGame.fen();
      var currEval = await evaluatePosition(currFen, 12);
      
      // Calculate eval drop (from moving player's perspective)
      var movingColor = moveHistory[moveIndex].color;
      var evalDrop;
      if (movingColor === 'w') {
        evalDrop = prevEval - currEval;
      } else {
        evalDrop = currEval - prevEval;
      }
      
      // Classify move
      var classification = classifyMove(evalDrop, moveIndex);
      analysisData[moveIndex] = {
        prevEval: prevEval,
        currEval: currEval,
        evalDrop: evalDrop,
        classification: classification
      };
      
      updatePGNTable();
      updateEvalBar(currEval);
      document.getElementById('statusBar').textContent = 'Analysis complete';
    } catch (e) {
      console.error('Analysis error:', e);
      document.getElementById('statusBar').textContent = 'Analysis failed';
    }
  }

  function classifyMove(evalDrop, moveIndex) {
    // First few moves are usually book
    if (moveIndex < 6) return 'book';
    
    if (evalDrop <= -50) return 'brilliant';
    if (evalDrop <= -20) return 'great';
    if (evalDrop <= 10) return 'best';
    if (evalDrop <= 30) return 'good';
    if (evalDrop <= 100) return 'inaccuracy';
    if (evalDrop <= 200) return 'mistake';
    return 'blunder';
  }

  function getMoveIcon(classification) {
    switch(classification) {
      case 'best':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#4ade80"/><text x="8" y="12" text-anchor="middle" font-size="11" fill="white" font-weight="bold">‚úì</text></svg>';
      case 'great':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#22c55e"/><text x="8" y="12" text-anchor="middle" font-size="11" fill="white" font-weight="bold">!</text></svg>';
      case 'good':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#84cc16"/><circle cx="8" cy="8" r="2.5" fill="white"/></svg>';
      case 'inaccuracy':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#f59e0b"/><text x="8" y="12" text-anchor="middle" font-size="10" fill="white" font-weight="bold">?!</text></svg>';
      case 'mistake':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#f97316"/><text x="8" y="12" text-anchor="middle" font-size="11" fill="white" font-weight="bold">?</text></svg>';
      case 'blunder':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#ef4444"/><text x="8" y="11" text-anchor="middle" font-size="9" fill="white" font-weight="bold">??</text></svg>';
      case 'brilliant':
        return '<svg width="16" height="16"><defs><linearGradient id="bg"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#f59e0b"/></linearGradient></defs><circle cx="8" cy="8" r="7" fill="url(#bg)"/><text x="8" y="12" text-anchor="middle" font-size="11" fill="white">‚≠ê</text></svg>';
      case 'interesting':
        return '<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="#3b82f6"/><text x="8" y="11" text-anchor="middle" font-size="9" fill="white" font-weight="bold">!?</text></svg>';
      default:
        return '';
    }
  }

  // ========================
  // UI Updates
  // ========================
  function updatePGNTable() {
    var tbody = document.getElementById('pgnTableBody');
    tbody.innerHTML = '';
    
    if (moveHistory.length === 0) {
      tbody.innerHTML = '<tr><td colspan="3" style="text-align:center; color:#888;">No moves yet</td></tr>';
      return;
    }
    
    for (var i = 0; i < moveHistory.length; i += 2) {
      var row = document.createElement('tr');
      var moveNum = Math.floor(i / 2) + 1;
      
      // Move number
      var numCell = document.createElement('td');
      numCell.className = 'move-number';
      numCell.textContent = moveNum + '.';
      row.appendChild(numCell);
      
      // White move
      var whiteCell = document.createElement('td');
      whiteCell.className = 'move-cell';
      whiteCell.dataset.index = i;
      var whiteText = document.createElement('span');
      whiteText.className = 'move-text';
      whiteText.textContent = moveHistory[i].san;
      whiteCell.appendChild(whiteText);
      
      if (analysisData[i]) {
        var whiteIcon = document.createElement('span');
        whiteIcon.className = 'move-icon';
        whiteIcon.innerHTML = getMoveIcon(analysisData[i].classification);
        whiteCell.appendChild(whiteIcon);
      }
      
      if (i === currentMoveIndex) whiteCell.classList.add('current');
      whiteCell.onclick = function() { goToMove(parseInt(this.dataset.index)); };
      row.appendChild(whiteCell);
      
      // Black move
      var blackCell = document.createElement('td');
      if (i + 1 < moveHistory.length) {
        blackCell.className = 'move-cell';
        blackCell.dataset.index = i + 1;
        var blackText = document.createElement('span');
        blackText.className = 'move-text';
        blackText.textContent = moveHistory[i + 1].san;
        blackCell.appendChild(blackText);
        
        if (analysisData[i + 1]) {
          var blackIcon = document.createElement('span');
          blackIcon.className = 'move-icon';
          blackIcon.innerHTML = getMoveIcon(analysisData[i + 1].classification);
          blackCell.appendChild(blackIcon);
        }
        
        if (i + 1 === currentMoveIndex) blackCell.classList.add('current');
        blackCell.onclick = function() { goToMove(parseInt(this.dataset.index)); };
      }
      row.appendChild(blackCell);
      
      tbody.appendChild(row);
    }
  }

  function updateEvalBar(evaluation) {
    // Convert centipawns to percentage (0-100)
    // Positive = white advantage
    var evalBar = document.getElementById('evalBar');
    var evalNumber = document.getElementById('evalNumber');
    
    // Clamp evaluation between -1000 and 1000 for display
    var clampedEval = Math.max(-1000, Math.min(1000, evaluation));
    
    // Convert to percentage (50% = equal, 0% = black winning, 100% = white winning)
    var percentage = 50 + (clampedEval / 20);
    percentage = Math.max(0, Math.min(100, percentage));
    
    evalBar.style.height = percentage + '%';
    
    // Update number display
    var displayEval = (evaluation / 100).toFixed(1);
    if (evaluation > 0) {
      evalNumber.textContent = '+' + displayEval;
      evalNumber.style.color = '#fff';
    } else if (evaluation < 0) {
      evalNumber.textContent = displayEval;
      evalNumber.style.color = '#fff';
    } else {
      evalNumber.textContent = '0.0';
      evalNumber.style.color = '#fff';
    }
    
    // Handle mate scores
    if (Math.abs(evaluation) >= 10000) {
      var mateIn = Math.abs(evaluation) === 10000 ? 1 : Math.ceil((Math.abs(evaluation) - 10000) / 100);
      evalNumber.textContent = (evaluation > 0 ? '+M' : '-M') + mateIn;
      evalBar.style.height = evaluation > 0 ? '100%' : '0%';
    }
  }

  function goToMove(index) {
    currentMoveIndex = index;
    
    // Rebuild position
    game.reset();
    for (var i = 0; i <= index; i++) {
      game.move(moveHistory[i]);
    }
    
    board.position(game.fen());
    updatePGNTable();
    
    // Update eval bar
    if (analysisData[index]) {
      updateEvalBar(analysisData[index].currEval);
    }
  }

  // ========================
  // Controls
  // ========================
  document.getElementById('firstBtn').onclick = function() {
    if (moveHistory.length === 0) return;
    game.reset();
    board.position('start');
    currentMoveIndex = -1;
    updatePGNTable();
    updateEvalBar(0);
  };

  document.getElementById('prevBtn').onclick = function() {
    if (currentMoveIndex < 0) return;
    currentMoveIndex--;
    
    game.reset();
    for (var i = 0; i <= currentMoveIndex; i++) {
      game.move(moveHistory[i]);
    }
    
    board.position(game.fen());
    updatePGNTable();
    
    if (currentMoveIndex >= 0 && analysisData[currentMoveIndex]) {
      updateEvalBar(analysisData[currentMoveIndex].currEval);
    } else {
      updateEvalBar(0);
    }
  };

  document.getElementById('nextBtn').onclick = function() {
    if (currentMoveIndex >= moveHistory.length - 1) return;
    currentMoveIndex++;
    
    game.move(moveHistory[currentMoveIndex]);
    board.position(game.fen());
    updatePGNTable();
    
    if (analysisData[currentMoveIndex]) {
      updateEvalBar(analysisData[currentMoveIndex].currEval);
    }
  };

  document.getElementById('lastBtn').onclick = function() {
    if (moveHistory.length === 0) return;
    currentMoveIndex = moveHistory.length - 1;
    
    game.reset();
    for (var i = 0; i <= currentMoveIndex; i++) {
      game.move(moveHistory[i]);
    }
    
    board.position(game.fen());
    updatePGNTable();
    
    if (analysisData[currentMoveIndex]) {
      updateEvalBar(analysisData[currentMoveIndex].currEval);
    }
  };

  document.getElementById('flipBtn').onclick = function() {
    board.flip();
  };

  document.getElementById('analyzeBtn').onclick = async function() {
    if (moveHistory.length === 0) {
      alert('No moves to analyze!');
      return;
    }
    
    if (!engineReady) {
      alert('Engine not ready yet. Please wait...');
      return;
    }
    
    document.getElementById('statusBar').innerHTML = '<span class="analyzing">Analyzing all moves...</span>';
    
    // Analyze all moves
    for (var i = 0; i < moveHistory.length; i++) {
      if (!analysisData[i]) {
        await analyzeMove(i);
        // Small delay to prevent overwhelming the engine
        await new Promise(r => setTimeout(r, 100));
      }
    }
    
    document.getElementById('statusBar').textContent = 'Full analysis complete!';
    updatePGNTable();
  };

  // ========================
  // Modal
  // ========================
  var modal = document.getElementById('infoModal');
  var infoBtn = document.getElementById('infoBtn');
  var closeModal = document.getElementById('closeModal');

  infoBtn.onclick = function() {
    modal.style.display = 'block';
  };

  closeModal.onclick = function() {
    modal.style.display = 'none';
  };

  window.onclick = function(event) {
    if (event.target == modal) {
      modal.style.display = 'none';
    }
  };

  // ========================
  // Sound
  // ========================
  function playSound(type) {
    var el = null;
    if (type === 'move') el = document.getElementById('moveSound');
    else if (type === 'capture') el = document.getElementById('captureSound');
    
    if (el) {
      el.currentTime = 0;
      el.play().catch(() => {});
    }
  }

  // ========================
  // Auto-analyze on move
  // ========================
  // When a move is made, it will automatically analyze
  // You can also use the analyze button to analyze all moves at once
  
  </script>
</body>
                                                                                      </html>
