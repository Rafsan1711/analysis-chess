<!DOCTYPE html>
<html lang="en">
<head>
    <title>Chess Bot Minimal + Drag + Click + Smooth Move + Sound + Effect</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" crossorigin="anonymous">
    <style>
        body {
            background: #fafafa;
        }
        .board-container {
            max-width: 420px;
            margin: 60px auto 0 auto;
        }
        #myBoard {
            width: 100%;
            min-width: 320px;
            min-height: 320px;
        }
        .highlight-click {
            box-shadow: 0 0 8px 4px orange inset;
        }
        .highlight-target {
            box-shadow: 0 0 4px 2px green inset;
        }
        .move-effect {
            animation: boardMoveEffect 0.4s;
        }
        @keyframes boardMoveEffect {
            0% { box-shadow: 0 0 10px 4px #33dd33 inset; }
            100% { box-shadow: none; }
        }
        /* Smooth piece movement fix for Chessboard.js */
        .chessboard-js-piece {
            transition: top 0.25s, left 0.25s;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="board-container">
        <div id="myBoard"></div>
    </div>
    <!-- Sound Effects -->
    <audio id="moveSound" src="sounds/move.mp3"></audio>
    <audio id="captureSound" src="sounds/capture.mp3"></audio>
    <audio id="promoteSound" src="sounds/promote.mp3"></audio>
    <audio id="castlingSound" src="sounds/castling.mp3"></audio>
    <audio id="incorrectMoveSound" src="sounds/incorrect-move.mp3"></audio>
    <audio id="checkSound" src="sounds/check.mp3"></audio>
    <audio id="checkmateSound" src="sounds/checkmate.mp3"></audio>

    <script src="https://code.jquery.com/jquery-3.5.1.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js" crossorigin="anonymous"></script>
    <script src="js/chess.js"></script>
    <script>
    // ===== Candidate piece filenames (we will probe these and pick first that loads) =====
    var pieceCandidates = {
      'wK': ['pieces/wK.svg', 'pieces/wKing.svg', 'pieces/WK.svg'],
      'wQ': ['pieces/wQ.svg', 'pieces/wQueen.svg', 'pieces/WQ.svg'],
      'wR': ['pieces/wR.svg', 'pieces/wRook.svg', 'pieces/WR.svg'],
      'wB': ['pieces/wB.svg', 'pieces/wBishop.svg', 'pieces/WB.svg'],
      'wN': ['pieces/wN.svg', 'pieces/wKnight.svg', 'pieces/WN.svg', 'pieces/wn.svg'],
      'wP': ['pieces/wP.svg', 'pieces/wPawn.svg', 'pieces/WP.svg'],
      'bK': ['pieces/bK.svg', 'pieces/bKing.svg', 'pieces/BK.svg'],
      'bQ': ['pieces/bQ.svg', 'pieces/bQueen.svg', 'pieces/BQ.svg'],
      'bR': ['pieces/bR.svg', 'pieces/bRook.svg', 'pieces/BR.svg'],
      'bB': ['pieces/bB.svg', 'pieces/bBishop.svg', 'pieces/BB.svg'],
      // NOTE: knights often have inconsistent filenames on some assets -> include many fallbacks
      'bN': ['pieces/bN.svg', 'pieces/bKnight.svg', 'pieces/BN.svg', 'pieces/bn.svg', 'pieces/black-knight.svg'],
      'bP': ['pieces/bP.svg', 'pieces/bPawn.svg', 'pieces/BP.svg']
    };

    // This will hold the resolved working URL for each piece (after probing)
    var pieceImgResolved = {};

    // Helper to load an image and return a Promise
    function loadImage(url) {
      return new Promise(function(resolve, reject) {
        var img = new Image();
        img.onload = function() { resolve(url); };
        img.onerror = function() { reject(url); };
        img.src = url;
      });
    }

    // Resolve candidates for a single piece: try each candidate sequentially
    async function resolvePiece(pieceKey, candidates) {
      for (var i = 0; i < candidates.length; i++) {
        try {
          var ok = await loadImage(candidates[i]);
          console.log('Loaded piece', pieceKey, '->', candidates[i]);
          return candidates[i];
        } catch (e) {
          // failed to load this candidate, try next
          // console.warn('Failed to load', candidates[i]);
        }
      }
      // none worked -> return null (caller will fallback)
      console.warn('No image found for', pieceKey, 'tried:', candidates);
      return null;
    }

    // Resolve all pieces; returns a Promise that resolves when done
    async function resolveAllPieces() {
      var keys = Object.keys(pieceCandidates);
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        var resolved = await resolvePiece(k, pieceCandidates[k]);
        pieceImgResolved[k] = resolved;
      }
      // if any essential piece not found, try fallback strategies:
      // e.g., if bN not found, try to use wN (mirrored style) or a generic placeholder
      if (!pieceImgResolved['bN']) {
        if (pieceImgResolved['wN']) {
          console.warn('Falling back: using white knight image for bN');
          pieceImgResolved['bN'] = pieceImgResolved['wN'];
        } else {
          console.warn('No knight images found at all; using first available image as placeholder.');
          // pick any available image
          for (var p in pieceImgResolved) {
            if (pieceImgResolved[p]) { pieceImgResolved['bN'] = pieceImgResolved[p]; break; }
          }
        }
      }
      // ensure all keys have SOME value (if still null, pick any valid one)
      for (var k2 in pieceImgResolved) {
        if (!pieceImgResolved[k2]) {
          for (var p2 in pieceImgResolved) {
            if (pieceImgResolved[p2]) { pieceImgResolved[k2] = pieceImgResolved[p2]; break; }
          }
        }
      }
      return pieceImgResolved;
    }

    // ===== Chess AI Logic (unchanged) =====
    var weights = { p: 100, n: 280, b: 320, r: 479, q: 929, k: 60000, k_e: 60000 };
    var pst_w = {
      p: [[100,100,100,100,105,100,100,100],[78,83,86,73,102,82,85,90],[7,29,21,44,40,31,44,7],[-17,16,-2,15,14,0,15,-13],[-26,3,10,9,6,1,0,-23],[-22,9,5,-11,-10,-2,3,-19],[-31,8,-7,-37,-36,-14,3,-31],[0,0,0,0,0,0,0,0]],
      n: [[-66,-53,-75,-75,-10,-55,-58,-70],[-3,-6,100,-36,4,62,-4,-14],[10,67,1,74,73,27,62,-2],[24,24,45,37,33,41,25,17],[-1,5,31,21,22,35,2,0],[-18,10,13,22,18,15,11,-14],[-23,-15,2,0,2,0,-23,-20],[-74,-23,-26,-24,-19,-35,-22,-69]],
      b: [[-59,-78,-82,-76,-23,-107,-37,-50],[-11,20,35,-42,-39,31,2,-22],[-9,39,-32,41,52,-10,28,-14],[25,17,20,34,26,25,15,10],[13,10,17,23,17,16,0,7],[14,25,24,15,8,25,20,15],[19,20,11,6,7,6,20,16],[-7,2,-15,-12,-14,-15,-10,-10]],
      r: [[35,29,33,4,37,33,56,50],[55,29,56,67,55,62,34,60],[19,35,28,33,45,27,25,15],[0,5,16,13,18,-4,-9,-6],[-28,-35,-16,-21,-13,-29,-46,-30],[-42,-28,-42,-25,-25,-35,-26,-46],[-53,-38,-31,-26,-29,-43,-44,-53],[-30,-24,-18,5,-2,-18,-31,-32]],
      q: [[6,1,-8,-104,69,24,88,26],[14,32,60,-10,20,76,57,24],[-2,43,32,60,72,63,43,2],[1,-16,22,17,25,20,-13,-6],[-14,-15,-2,-5,-1,-10,-20,-22],[-30,-6,-13,-11,-16,-11,-16,-27],[-36,-18,0,-19,-15,-15,-21,-38],[-39,-30,-31,-13,-31,-36,-34,-42]],
      k: [[4,54,47,-99,-99,60,83,-62],[-32,10,55,56,56,55,10,3],[-62,12,-57,44,-67,28,37,-31],[-55,50,11,-4,-19,13,0,-49],[-55,-43,-52,-28,-51,-47,-8,-50],[-47,-42,-43,-79,-64,-32,-29,-32],[-4,3,-14,-50,-57,-18,13,4],[17,30,-3,-14,6,-1,40,18]],
      k_e: [[-50,-40,-30,-20,-20,-30,-40,-50],[-30,-20,-10,0,0,-10,-20,-30],[-30,-10,20,30,30,20,-10,-30],[-30,-10,30,40,40,30,-10,-30],[-30,-10,30,40,40,30,-10,-30],[-30,-10,20,30,30,20,-10,-30],[-30,-30,0,0,0,0,-30,-30],[-50,-30,-30,-30,-30,-30,-30,-50]]
    };
    var pst_b = {
      p: pst_w['p'].slice().reverse(),
      n: pst_w['n'].slice().reverse(),
      b: pst_w['b'].slice().reverse(),
      r: pst_w['r'].slice().reverse(),
      q: pst_w['q'].slice().reverse(),
      k: pst_w['k'].slice().reverse(),
      k_e: pst_w['k_e'].slice().reverse(),
    };
    var pstOpponent = { w: pst_b, b: pst_w };
    var pstSelf = { w: pst_w, b: pst_b };

    var board = null;
    var game = new Chess();
    var globalSum = 0; // from black's perspective

    function playSound(type) {
      var el = null;
      switch(type) {
        case "move": el = document.getElementById("moveSound"); break;
        case "capture": el = document.getElementById("captureSound"); break;
        case "promote": el = document.getElementById("promoteSound"); break;
        case "castling": el = document.getElementById("castlingSound"); break;
        case "incorrect": el = document.getElementById("incorrectMoveSound"); break;
        case "check": el = document.getElementById("checkSound"); break;
        case "checkmate": el = document.getElementById("checkmateSound"); break;
      }
      if (el) { el.currentTime = 0; el.play().catch(()=>{}); }
    }

    // Effect helper
    function boardMoveEffect(square) {
      var $sq = $('#myBoard .square-' + square);
      $sq.addClass('move-effect');
      setTimeout(function() { $sq.removeClass('move-effect'); }, 400);
    }

    function evaluateBoard(game, move, prevSum, color) {
      if (game.in_checkmate()) {
        if (move.color === color) return 1e10;
        else return -1e10;
      }
      if (game.in_draw() || game.in_threefold_repetition() || game.in_stalemate()) return 0;
      if (game.in_check()) {
        if (move.color === color) prevSum += 50;
        else prevSum -= 50;
      }
      var from = [8 - parseInt(move.from[1]), move.from.charCodeAt(0) - 'a'.charCodeAt(0)];
      var to = [8 - parseInt(move.to[1]), move.to.charCodeAt(0) - 'a'.charCodeAt(0)];
      if (prevSum < -1500 && move.piece === 'k') move.piece = 'k_e';
      if ('captured' in move) {
        if (move.color === color) {
          prevSum += weights[move.captured] + pstOpponent[move.color][move.captured][to[0]][to[1]];
        } else {
          prevSum -= weights[move.captured] + pstSelf[move.color][move.captured][to[0]][to[1]];
        }
      }
      if (move.flags && move.flags.includes('p')) {
        move.promotion = 'q';
        if (move.color === color) {
          prevSum -= weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]];
          prevSum += weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]];
        } else {
          prevSum += weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]];
          prevSum -= weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]];
        }
      } else {
        if (move.color !== color) {
          prevSum += pstSelf[move.color][move.piece][from[0]][from[1]];
          prevSum -= pstSelf[move.color][move.piece][to[0]][to[1]];
        } else {
          prevSum -= pstSelf[move.color][move.piece][from[0]][from[1]];
          prevSum += pstSelf[move.color][move.piece][to[0]][to[1]];
        }
      }
      return prevSum;
    }

    function minimax(game, depth, alpha, beta, isMaximizingPlayer, sum, color) {
      var children = game.ugly_moves({ verbose: true });
      children.sort(function () { return 0.5 - Math.random(); });
      if (depth === 0 || children.length === 0) return [null, sum];
      var maxValue = Number.NEGATIVE_INFINITY, minValue = Number.POSITIVE_INFINITY, bestMove;
      for (var i = 0; i < children.length; i++) {
        var currMove = children[i];
        var currPrettyMove = game.ugly_move(currMove);
        var newSum = evaluateBoard(game, currPrettyMove, sum, color);
        var [, childValue] = minimax(game, depth - 1, alpha, beta, !isMaximizingPlayer, newSum, color);
        game.undo();
        if (isMaximizingPlayer) {
          if (childValue > maxValue) { maxValue = childValue; bestMove = currPrettyMove; }
          if (childValue > alpha) alpha = childValue;
        } else {
          if (childValue < minValue) { minValue = childValue; bestMove = currPrettyMove; }
          if (childValue < beta) beta = childValue;
        }
        if (alpha >= beta) break;
      }
      return isMaximizingPlayer ? [bestMove, maxValue] : [bestMove, minValue];
    }

    function getBestMove(game, color, currSum) {
      var depth = 2;
      var [bestMove, ] = minimax(game, depth, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, true, currSum, color);
      return bestMove;
    }

    // ===== Initialize board AFTER resolving piece images =====
    (async function init() {
      try {
        await resolveAllPieces();
      } catch (e) {
        console.error('Error resolving piece images:', e);
      }

      // If something very strange happened and a piece url is undefined, use a safe fallback
      var defaultAny = null;
      for (var k in pieceImgResolved) { if (pieceImgResolved[k]) { defaultAny = pieceImgResolved[k]; break; } }
      for (var kk in pieceImgResolved) { if (!pieceImgResolved[kk]) pieceImgResolved[kk] = defaultAny; }

      // Build a simple pieceTheme function that returns the resolved map
      function pieceTheme(piece) {
        // piece is like 'wN' or 'bK'
        if (pieceImgResolved && pieceImgResolved[piece]) return pieceImgResolved[piece];
        // fallback
        console.warn('No resolved image for', piece, 'using a fallback.');
        return defaultAny;
      }

      // Now create the board config (kept same as before except pieceTheme now uses resolved map)
      var config = {
        draggable: true,
        position: 'start',
        pieceTheme: pieceTheme,
        moveSpeed: 250,
        snapbackSpeed: 200,
        snapSpeed: 100,
        onDragStart: function(source, piece) {
          // Don't allow drag if game is over or not your piece
          if (game.game_over()) return false;
          if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
              (game.turn() === 'b' && piece.search(/^w/) !== -1)) return false;
        },
        onDrop: function(source, target) {
          // Try to move, if illegal play incorrect sound
          var move = game.move({ from: source, to: target, promotion: 'q' });
          if (move === null) {
            playSound("incorrect");
            return 'snapback';
          }
          // Indicate this came from a drag so we don't immediately re-set board.position (avoid double animation)
          doMoveLogic(move, source, target, true);
          return;
        },
        onSnapEnd: function() {
          // ONLY update the board here after a drag-based move finished its internal animation.
          board.position(game.fen());
        }
      };
      board = Chessboard('myBoard', config);

      // Fix: make Chessboard.js piece movement always smooth (keeps the CSS transition)
      setTimeout(function() {
        $('#myBoard .chessboard-js-piece').css('transition', 'top 0.25s, left 0.25s');
      }, 1000);
    })();

    // ===== Piece Move Logic (drag+click) + Sound + Effects (unchanged) =====
    function doMoveLogic(move, source, target, isDrag) {
      playMoveEffectAndSound(move);
      boardMoveEffect(source);
      boardMoveEffect(target);
      globalSum = evaluateBoard(game, move, globalSum, 'b');

      // For drag-based moves we MUST NOT call board.position immediately (onSnapEnd will do it once)
      if (!isDrag) {
        // click-based move or programmatic move -> update board now
        board.position(game.fen());
      }

      clearHighlights();
      selectedSquare = null;

      // Bot move (programmatic). For user-drag move, we still wait and then let bot move.
      setTimeout(function() {
        if (!game.game_over() && game.turn() === 'b') {
          var botMove = getBestMove(game, 'b', globalSum);
          if (botMove) {
            game.move(botMove);
            playMoveEffectAndSound(botMove);
            boardMoveEffect(botMove.from);
            boardMoveEffect(botMove.to);
            globalSum = evaluateBoard(game, botMove, globalSum, 'b');
            // programmatic bot move -> update board immediately (no onSnapEnd for programmatic)
            board.position(game.fen());
          }
        }
      }, 350);
    }

    function playMoveEffectAndSound(move) {
      // Castling
      if (move.flags.includes('k') || move.flags.includes('q')) {
        playSound("castling");
      }
      // Promotion
      else if (move.flags.includes('p')) {
        playSound("promote");
      }
      // Capture
      else if (move.flags.includes('c') || move.flags.includes('e')) {
        playSound("capture");
      }
      // Normal
      else {
        playSound("move");
      }
      // Check/Checkmate
      if (game.in_checkmate()) {
        playSound("checkmate");
      } else if (game.in_check()) {
        playSound("check");
      }
    }

    // ===== Click-to-move implementation (like chess.com/lichess) =====
    var selectedSquare = null;
    var legalTargets = [];

    function clearHighlights() {
      $('#myBoard .square-55d63').removeClass('highlight-click');
      $('#myBoard .square-55d63').removeClass('highlight-target');
    }

    function highlightSquares(squares, highlightClass) {
      squares.forEach(function(sq) {
        $('#myBoard .square-' + sq).addClass(highlightClass);
      });
    }

    // Click logic: select, show targets, click target to move
    $('#myBoard').on('click', '.square-55d63', function() {
      var square = $(this).attr('data-square');
      if (game.game_over()) return;
      // If no selection: select your own piece
      if (!selectedSquare) {
        var piece = game.get(square);
        if (!piece || piece.color !== game.turn()) return;
        selectedSquare = square;
        clearHighlights();
        $('#myBoard .square-' + square).addClass('highlight-click');
        var moves = game.moves({ square: square, verbose: true });
        legalTargets = moves.map(function(move) { return move.to; });
        highlightSquares(legalTargets, 'highlight-target');
      } else {
        // If clicked same square, deselect
        if (square === selectedSquare) {
          selectedSquare = null;
          legalTargets = [];
          clearHighlights();
          return;
        }
        // If clicked target square, try move
        if (legalTargets.includes(square)) {
          var move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
          if (move === null) {
            playSound("incorrect");
            clearHighlights();
            selectedSquare = null;
            legalTargets = [];
            board.position(game.fen());
            return;
          }
          doMoveLogic(move, selectedSquare, square, false);
          return;
        }
        // If clicked another own piece, switch selection
        var piece2 = game.get(square);
        if (piece2 && piece2.color === game.turn()) {
          selectedSquare = square;
          clearHighlights();
          $('#myBoard .square-' + square).addClass('highlight-click');
          var moves = game.moves({ square: square, verbose: true });
          legalTargets = moves.map(function(move) { return move.to; });
          highlightSquares(legalTargets, 'highlight-target');
          return;
        }
        // Else, deselect
        selectedSquare = null;
        legalTargets = [];
        clearHighlights();
      }
    });
    // Deselect on outside click
    $(document).on('click', function(e){
      if ($(e.target).closest('#myBoard').length === 0) {
        clearHighlights();
        selectedSquare = null;
        legalTargets = [];
      }
    });
    // If drag starts, clear highlight
    $('#myBoard').on('mousedown', '.square-55d63', function() {
      clearHighlights();
      selectedSquare = null;
      legalTargets = [];
    });

    </script>
</body>
    </html>
