<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Pro Chess Analysis — Stable</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- chessboard core css (unchanged) -->
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" crossorigin="anonymous">

  <!-- Minimal / GitHub-like UI -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet" crossorigin="anonymous">
  <style>
    :root{
      --bg:#0f1720; /* dark slate */
      --panel:#0b1220;
      --muted:#9aa4b2;
      --accent:#58a6ff;
      --card:#0b1220;
      --glass: rgba(255,255,255,0.02);
    }
    html,body { height:100%; margin:0; background:linear-gradient(180deg,var(--bg),#07101a); font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:#e6eef6; }
    .app { max-width:1200px; margin:24px auto; padding:20px; }
    .topbar { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:18px; }
    .brand { display:flex; align-items:center; gap:12px; }
    .brand .logo { width:44px; height:44px; border-radius:8px; background:linear-gradient(135deg,var(--accent),#2dd4bf); display:flex; align-items:center; justify-content:center; color:#021; font-weight:700; }
    .brand h1 { font-size:1.05rem; margin:0; font-weight:600; color:#e6eef6; }
    .controls button { margin-right:8px; }

    /* Panels */
    .panel { background:var(--panel); border-radius:10px; padding:12px; box-shadow: 0 6px 20px rgba(2,6,23,0.6); border:1px solid rgba(255,255,255,0.03); }
    .small-muted { color:var(--muted); font-size:0.86rem; }

    /* Boards */
    #myBoard, #analysisBoard { width:100%; max-width:420px; margin: 0 auto; }
    .chessboard-js-piece { transition: top 0.25s, left 0.25s; z-index: 10; }

    /* Analysis layout */
    .layout { display:grid; grid-template-columns: 1fr 420px; gap:18px; align-items:start; }
    @media (max-width: 980px) { .layout { grid-template-columns: 1fr; } }

    #analysisSection { display:none; margin-top:12px; }
    #pgnInput { width:100%; min-height:120px; font-family: monospace; background:transparent; color:#e6eef6; border:1px solid rgba(255,255,255,0.04); padding:8px; border-radius:6px; }
    .progress { height:10px; background: rgba(255,255,255,0.03); border-radius:6px; overflow:hidden; }
    .progress-bar { background: linear-gradient(90deg,var(--accent), #2dd4bf); }

    #evalBar { width:64px; height:420px; background:linear-gradient(180deg,#05101a,#061014); border-radius:8px; position:relative; border:1px solid rgba(255,255,255,0.03); }
    #evalFill { position:absolute; left:6px; right:6px; bottom:6px; height:50%; background:linear-gradient(#fff59d,#ffd54f); border-radius:6px; transition:height 0.3s, background 0.3s; }
    #evalCenter { position:absolute; left:2px; right:2px; top:50%; height:1px; background:rgba(255,255,255,0.06); }

    .usernames { display:flex; justify-content:space-between; gap:8px; margin-top:8px; }
    .username { font-weight:600; color:#f2f8ff; font-size:0.95rem; }
    .meta { color:var(--muted); font-size:0.86rem; }

    .table-scroll { max-height:340px; overflow:auto; }
    #pgnMoveTable tbody tr:hover { background: rgba(255,255,255,0.02); cursor:pointer; }

    /* tags */
    .tag { padding:4px 8px; border-radius:999px; font-weight:700; font-size:0.78rem; display:inline-block; }
    .tag.brilliant{ color:#4b2e00; background:#ffd780; }
    .tag.great{ color:#083b1f; background:#b7f3c2; }
    .tag.best{ color:#06324a; background:#bfe8ff; }
    .tag.excellent{ color:#083c12; background:#aef2c4; }
    .tag.good{ color:#083c12; background:#9ee7b6; }
    .tag.book{ color:#17344b; background:#d6f0ff; }
    .tag.inacc{ color:#5a3300; background:#ffd9a8; }
    .tag.mistake{ color:#381200; background:#ffb59a; }
    .tag.miss{ color:#fff; background:#ff8b5a; }
    .tag.blunder{ color:#fff; background:#d75a5a; }

    /* minimal footer note */
    .note { margin-top:12px; color:var(--muted); font-size:0.85rem; }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">
        <div class="logo">CA</div>
        <div>
          <h1>Pro Chess Analysis</h1>
          <div class="small-muted">Minimal • Accurate • Professional</div>
        </div>
      </div>
      <div class="controls">
        <button id="btnHumanBot" class="btn btn-sm btn-outline-light"><i class="fa fa-chess"></i> Human vs Bot</button>
        <button id="btnAnalysis" class="btn btn-sm btn-light"><i class="fa fa-signal"></i> Analysis Board</button>
      </div>
    </div>

    <!-- Human vs Bot default panel (keeps your previous board intact) -->
    <div id="humanPanel" class="panel">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <div class="username">Play vs Bot</div>
          <div class="meta">Drag pieces to play. Sounds & animations enabled.</div>
        </div>
        <div id="engineStatus" class="meta">Engine: initializing...</div>
      </div>
      <div style="margin-top:12px; display:flex; justify-content:center;">
        <div id="myBoard"></div>
      </div>
    </div>

    <!-- Analysis Panel -->
    <div id="analysisSection" class="panel" style="margin-top:16px;">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
        <div>
          <div class="username" id="analysisTitle">Analysis</div>
          <div class="meta">Paste PGN, run analysis (engine-backed), inspect annotated moves and evaluation graph.</div>
        </div>
        <div>
          <button id="backBtn" class="btn btn-sm btn-outline-light"><i class="fa fa-arrow-left"></i> Back</button>
        </div>
      </div>

      <div style="margin-top:12px" class="layout">
        <!-- Left column: controls, PGN, moves -->
        <div>
          <div style="display:flex; gap:8px; align-items:center;">
            <button id="loadPGN" class="btn btn-sm btn-primary"><i class="fa fa-upload"></i> Load & Analyze PGN</button>
            <button id="stopAnalysis" class="btn btn-sm btn-danger" disabled><i class="fa fa-stop"></i> Stop</button>
            <div style="margin-left:auto; display:flex; gap:6px;">
              <button id="undoMove" class="btn btn-sm btn-outline-warning" disabled><i class="fa fa-undo"></i></button>
              <button id="redoMove" class="btn btn-sm btn-outline-info" disabled><i class="fa fa-redo"></i></button>
            </div>
          </div>

          <div style="margin-top:10px;">
            <textarea id="pgnInput" placeholder="Paste PGN here (including tags)."></textarea>
          </div>

          <div style="margin-top:10px;">
            <div class="progress"><div id="analysisProgress" class="progress-bar" role="progressbar" style="width:0%">0%</div></div>
          </div>

          <div style="margin-top:12px; display:flex; gap:8px; align-items:center;">
            <div class="username" id="whiteName">White: —</div>
            <div class="small-muted">|</div>
            <div class="username" id="blackName">Black: —</div>
          </div>

          <div style="margin-top:12px;" class="table-scroll panel" id="movesPanel">
            <table class="table table-sm table-borderless mb-0" id="pgnMoveTable">
              <thead style="color:var(--muted); border-bottom:1px solid rgba(255,255,255,0.03)">
                <tr><th style="width:10%;">#</th><th style="width:35%;">White</th><th style="width:15%;">Tag</th><th style="width:35%;">Black</th><th style="width:15%;">Tag</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <div class="note">Tip: Click a move-row to jump to that position. "Equal" labels are intentionally avoided — Good is used for small/no-difference moves.</div>
        </div>

        <!-- Right column: board, evalbar, chart -->
        <div style="display:flex; flex-direction:column; align-items:center; gap:10px;">
          <div id="analysisBoard" style="width:420px; height:420px;" class="panel"></div>
          <div style="display:flex; gap:12px; align-items:center;">
            <div id="evalBar">
              <div id="evalFill"></div>
              <div id="evalCenter"></div>
            </div>
            <div style="width:420px; height:200px;" class="panel">
              <canvas id="moveEvalChart" style="width:100%; height:100%"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div style="margin-top:18px; color:var(--muted); font-size:0.9rem;">Built from your code — kept sounds, piece resolver, engine init and fallback unchanged. Analysis upgraded for accuracy (best-move vs played-move centipawn-loss method).</div>
  </div>

  <!-- sounds (unchanged) -->
  <audio id="moveSound" src="sounds/move.mp3"></audio>
  <audio id="captureSound" src="sounds/capture.mp3"></audio>
  <audio id="promoteSound" src="sounds/promote.mp3"></audio>
  <audio id="castlingSound" src="sounds/castling.mp3"></audio>
  <audio id="incorrectMoveSound" src="sounds/incorrect-move.mp3"></audio>
  <audio id="checkSound" src="sounds/check.mp3"></audio>
  <audio id="checkmateSound" src="sounds/checkmate.mp3"></audio>

  <!-- libs -->
  <script src="https://code.jquery.com/jquery-3.5.1.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" crossorigin="anonymous"></script>

  <!-- local chess lib (must be present in your folder) -->
  <script src="js/chess.js"></script>

  <!-- ===========================
       === ORIGINAL CORE SCRIPT (kept mostly identical) ===
       =========================== -->
  <script>
  // -------------------------
  // piece resolver (unchanged)
  // -------------------------
  var pieceCandidates = {
    'wK':['pieces/wK.svg','pieces/wKing.svg','pieces/WK.svg'],
    'wQ':['pieces/wQ.svg','pieces/wQueen.svg','pieces/WQ.svg'],
    'wR':['pieces/wR.svg','pieces/wRook.svg','pieces/WR.svg'],
    'wB':['pieces/wB.svg','pieces/wBishop.svg','pieces/WB.svg'],
    'wN':['pieces/wN.svg','pieces/wKnight.svg','pieces/WN.svg','pieces/wn.svg'],
    'wP':['pieces/wP.svg','pieces/wPawn.svg','pieces/WP.svg'],
    'bK':['pieces/bK.svg','pieces/bKing.svg','pieces/BK.svg'],
    'bQ':['pieces/bQ.svg','pieces/bQueen.svg','pieces/BQ.svg'],
    'bR':['pieces/bR.svg','pieces/bRook.svg','pieces/BR.svg'],
    'bB':['pieces/bB.svg','pieces/bBishop.svg','pieces/BB.svg'],
    'bN':['pieces/bN.svg','pieces/bKnight.svg','pieces/BN.svg','pieces/bn.svg','pieces/black-knight.svg'],
    'bP':['pieces/bP.svg','pieces/bPawn.svg','pieces/BP.svg']
  };
  var pieceImgResolved = {};

  function loadImage(url){ return new Promise(function(resolve,reject){ var img=new Image(); img.onload=function(){resolve(url)}; img.onerror=function(){reject(url)}; img.src=url; }); }
  async function resolvePiece(key, candidates){
    for (var i=0;i<candidates.length;i++){
      try{ var ok = await loadImage(candidates[i]); console.log('Loaded piece', key, '->', candidates[i]); return candidates[i]; }
      catch(e){}
    }
    console.warn('No image found for', key, candidates);
    return null;
  }
  async function resolveAllPieces(){
    var keys=Object.keys(pieceCandidates);
    for (var i=0;i<keys.length;i++){ pieceImgResolved[keys[i]] = await resolvePiece(keys[i], pieceCandidates[keys[i]]); }
    if (!pieceImgResolved['bN']) {
      if (pieceImgResolved['wN']) pieceImgResolved['bN'] = pieceImgResolved['wN'];
      else { for (var p in pieceImgResolved) if (pieceImgResolved[p]) { pieceImgResolved['bN'] = pieceImgResolved[p]; break; } }
    }
    var defaultAny=null; for (var k in pieceImgResolved) if (pieceImgResolved[k]) { defaultAny = pieceImgResolved[k]; break; }
    for (var k2 in pieceImgResolved) if (!pieceImgResolved[k2]) pieceImgResolved[k2] = defaultAny;
    console.log('Resolved pieces:', pieceImgResolved);
    return pieceImgResolved;
  }

  // -------------------------
  // engine (Blob worker) + robust handling (unchanged)
  // -------------------------
  var board = null;
  var game = new Chess();
  var globalSum = 0;

  var aiMode = 'stockfish'; // 'stockfish' or 'minimax'
  var stockfishEngine = null;
  var engineReady = false;
  var engineBusy = false;
  var stockfishMovetime = 800;
  var engineOpts = {};
  var engineDefaultHandler = null;

  // new flags to prevent re-entrancy / overlapping moves
  var inputLocked = false;       // true while user action/bot thinking/applying move
  var processingMove = false;    // true inside doMoveLogic

  function computeEngineOptions(){
    var hwc = navigator.hardwareConcurrency || 2;
    var isMobile = /Mobi|Android/i.test(navigator.userAgent) || (window.innerWidth && window.innerWidth < 720);
    var threads = isMobile ? 1 : Math.min(4, Math.max(1, Math.floor(hwc)));
    var hash = isMobile ? 16 : 64;
    var movetime = isMobile ? 350 : (hwc >= 8 ? 1200 : 800);
    var skill = 20;
    engineOpts = {threads:threads, hash:hash, movetime:movetime, skill:skill, isMobile:isMobile, hwc:hwc};
    stockfishMovetime = movetime;
    return engineOpts;
  }

  function createStockfishBlobWorker(cdnUrl) {
    try {
      var blobCode = "importScripts('" + cdnUrl + "');";
      var blob = new Blob([blobCode], {type: 'application/javascript'});
      var blobURL = URL.createObjectURL(blob);
      var w = new Worker(blobURL);
      setTimeout(function(){ URL.revokeObjectURL(blobURL); }, 5000);
      return w;
    } catch (e) {
      console.error('createStockfishBlobWorker failed', e);
      return null;
    }
  }

  function textFromEvent(ev) {
    var d = (ev && ev.data !== undefined) ? ev.data : ev;
    if (typeof d === 'string') return d;
    try { return '' + d; } catch(e){ return String(d); }
  }

  function initStockfish() {
    var opts = computeEngineOptions();
    console.log('Engine options:', opts);
    document.getElementById('engineStatus').innerText = 'Engine: loading...';

    try {
      if (typeof STOCKFISH === 'function') {
        stockfishEngine = STOCKFISH();
      } else {
        var cdn = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
        stockfishEngine = createStockfishBlobWorker(cdn);
      }
    } catch (e) {
      console.warn('Stockfish init attempt failed:', e);
      stockfishEngine = null;
    }

    if (!stockfishEngine) {
      engineReady = false;
      document.getElementById('engineStatus').innerText = 'Engine: unavailable (fallback to minimax)';
      console.warn('Stockfish not available; using minimax fallback.');
      return;
    }

    engineDefaultHandler = function(ev) {
      var line = textFromEvent(ev).trim();
      if (!line) return;
      console.log('stockfish:', line);
      if (line.indexOf('readyok') !== -1) {
        engineReady = true;
        document.getElementById('engineStatus').innerText =
          'Engine: ready (Stockfish, skill ' + engineOpts.skill + ', threads ' + engineOpts.threads + ', hash ' + engineOpts.hash + 'MB)';
      }
    };

    try {
      stockfishEngine.onmessage = engineDefaultHandler;
      stockfishEngine.postMessage('uci');
      stockfishEngine.postMessage('setoption name Threads value ' + (engineOpts.threads || computeEngineOptions().threads));
      stockfishEngine.postMessage('setoption name Hash value ' + (engineOpts.hash || computeEngineOptions().hash));
      stockfishEngine.postMessage('setoption name Skill Level value ' + (engineOpts.skill || computeEngineOptions().skill));
      stockfishEngine.postMessage('setoption name UCI_LimitStrength value false');
      stockfishEngine.postMessage('isready');
    } catch (e) {
      console.error('Error configuring stockfish:', e);
    }
  }

  // Safe SF query: always restore handler & clear busy flag on all paths
  // This returns only the bestmove string (used by gameplay)
  function stockfishBestMove(fen, movetimeMs) {
    return new Promise(function(resolve, reject) {
      if (!stockfishEngine || !engineReady) return reject('engine not ready');
      if (engineBusy) return reject('engine busy');
      engineBusy = true;

      var prevHandler = stockfishEngine.onmessage;
      var timeoutId = null;

      var capture = function(ev) {
        var line = textFromEvent(ev).trim();
        if (!line) return;
        // pick bestmove
        if (line.indexOf('bestmove') === 0) {
          try {
            var parts = line.split(/\s+/);
            var best = parts[1];
            // restore handler & clear timeout
            try { stockfishEngine.onmessage = prevHandler; } catch(e) {}
            if (timeoutId) clearTimeout(timeoutId);
            engineBusy = false;
            resolve(best);
          } catch (err) {
            try { stockfishEngine.onmessage = prevHandler; } catch(e) {}
            if (timeoutId) clearTimeout(timeoutId);
            engineBusy = false;
            reject(err);
          }
        }
      };

      try {
        stockfishEngine.onmessage = capture;
        stockfishEngine.postMessage('position fen ' + fen);
        stockfishEngine.postMessage('go movetime ' + parseInt(movetimeMs,10));
      } catch (e) {
        try { stockfishEngine.onmessage = prevHandler; } catch(ignore) {}
        engineBusy = false;
        return reject(e);
      }

      // safety timeout (forces fallback)
      timeoutId = setTimeout(function() {
        try { stockfishEngine.onmessage = prevHandler; } catch(e) {}
        engineBusy = false;
        reject('timeout');
      }, Math.max(8000, movetimeMs + 4000));
    });
  }

  // -------------------------
  // minimax fallback (kept)
  // -------------------------
  var weights = { p:100,n:280,b:320,r:479,q:929,k:60000,k_e:60000 };
  var pst_w = {
    p: [[100,100,100,100,105,100,100,100],[78,83,86,73,102,82,85,90],[7,29,21,44,40,31,44,7],[-17,16,-2,15,14,0,15,-13],[-26,3,10,9,6,1,0,-23],[-22,9,5,-11,-10,-2,3,-19],[-31,8,-7,-37,-36,-14,3,-31],[0,0,0,0,0,0,0,0]],
    n: [[-66,-53,-75,-75,-10,-55,-58,-70],[-3,-6,100,-36,4,62,-4,-14],[10,67,1,74,73,27,62,-2],[24,24,45,37,33,41,25,17],[-1,5,31,21,22,35,2,0],[-18,10,13,22,18,15,11,-14],[-23,-15,2,0,2,0,-23,-20],[-74,-23,-26,-24,-19,-35,-22,-69]],
    b: [[-59,-78,-82,-76,-23,-107,-37,-50],[-11,20,35,-42,-39,31,2,-22],[-9,39,-32,41,52,-10,28,-14],[25,17,20,34,26,25,15,10],[13,10,17,23,17,16,0,7],[14,25,24,15,8,25,20,15],[19,20,11,6,7,6,20,16],[-7,2,-15,-12,-14,-15,-10,-10]],
    r: [[35,29,33,4,37,33,56,50],[55,29,56,67,55,62,34,60],[19,35,28,33,45,27,25,15],[0,5,16,13,18,-4,-9,-6],[-28,-35,-16,-21,-13,-29,-46,-30],[-42,-28,-42,-25,-25,-35,-26,-46],[-53,-38,-31,-26,-29,-43,-44,-53],[-30,-24,-18,5,-2,-18,-31,-32]],
    q: [[6,1,-8,-104,69,24,88,26],[14,32,60,-10,20,76,57,24],[-2,43,32,60,72,63,43,2],[1,-16,22,17,25,20,-13,-6],[-14,-15,-2,-5,-1,-10,-20,-22],[-30,-6,-13,-11,-16,-11,-16,-27],[-36,-18,0,-19,-15,-15,-21,-38],[-39,-30,-31,-13,-31,-36,-34,-42]],
    k: [[4,54,47,-99,-99,60,83,-62],[-32,10,55,56,56,55,10,3],[-62,12,-57,44,-67,28,37,-31],[-55,50,11,-4,-19,13,0,-49],[-55,-43,-52,-28,-51,-47,-8,-50],[-47,-42,-43,-79,-64,-32,-29,-32],[-4,3,-14,-50,-57,-18,13,4],[17,30,-3,-14,6,-1,40,18]],
    k_e: [[-50,-40,-30,-20,-20,-30,-40,-50],[-30,-20,-10,0,0,-10,-20,-30],[-30,-10,20,30,30,20,-10,-30],[-30,-10,30,40,40,30,-10,-30],[-30,-10,30,40,40,30,-10,-30],[-30,-10,20,30,30,20,-10,-30],[-30,-30,0,0,0,0,-30,-30],[-50,-30,-30,-30,-30,-30,-30,-50]]
  };
  var pst_b = { p: pst_w['p'].slice().reverse(), n: pst_w['n'].slice().reverse(), b: pst_w['b'].slice().reverse(), r: pst_w['r'].slice().reverse(), q: pst_w['q'].slice().reverse(), k: pst_w['k'].slice().reverse(), k_e: pst_w['k_e'].slice().reverse() };
  var pstOpponent = { w: pst_b, b: pst_w };
  var pstSelf = { w: pst_w, b: pst_b };

  function evaluateBoard(game, move, prevSum, color) {
    if (game.in_checkmate()) { if (move.color === color) return 1e10; else return -1e10; }
    if (game.in_draw() || game.in_threefold_repetition() || game.in_stalemate()) return 0;
    if (game.in_check()) { if (move.color === color) prevSum += 50; else prevSum -= 50; }
    var from = [8 - parseInt(move.from[1]), move.from.charCodeAt(0) - 'a'.charCodeAt(0)];
    var to = [8 - parseInt(move.to[1]), move.to.charCodeAt(0) - 'a'.charCodeAt(0)];
    if (prevSum < -1500 && move.piece === 'k') move.piece = 'k_e';
    if ('captured' in move) {
      if (move.color === color) prevSum += weights[move.captured] + pstOpponent[move.color][move.captured][to[0]][to[1]];
      else prevSum -= weights[move.captured] + pstSelf[move.color][move.captured][to[0]][to[1]];
    }
    if (move.flags && move.flags.includes('p')) {
      move.promotion = 'q';
      if (move.color === color) {
        prevSum -= weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum += weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]];
      } else {
        prevSum += weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum -= weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]];
      }
    } else {
      if (move.color !== color) {
        prevSum += pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum -= pstSelf[move.color][move.piece][to[0]][to[1]];
      } else {
        prevSum -= pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum += pstSelf[move.color][move.piece][to[0]][to[1]];
      }
    }
    return prevSum;
  }

  function minimax(game, depth, alpha, beta, isMax, sum, color) {
    var children = game.ugly_moves({ verbose: true });
    children.sort(function(){ return 0.5 - Math.random(); });
    if (depth === 0 || children.length === 0) return [null, sum];
    var maxV = Number.NEGATIVE_INFINITY, minV = Number.POSITIVE_INFINITY, best = null;
    for (var i=0;i<children.length;i++){
      var m = children[i];
      var pm = game.ugly_move(m);
      var newSum = evaluateBoard(game, pm, sum, color);
      var [, childVal] = minimax(game, depth-1, alpha, beta, !isMax, newSum, color);
      game.undo();
      if (isMax) {
        if (childVal > maxV) { maxV = childVal; best = pm; }
        if (childVal > alpha) alpha = childVal;
      } else {
        if (childVal < minV) { minV = childVal; best = pm; }
        if (childVal < beta) beta = childVal;
      }
      if (alpha >= beta) break;
    }
    return isMax ? [best, maxV] : [best, minV];
  }
  function getBestMoveMinimax(game, color, currSum) {
    var depth = 2;
    return minimax(game, depth, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, true, currSum, color)[0];
  }

  // -------------------------
  // UI init (original board)
  // -------------------------
  (async function init() {
    try { await resolveAllPieces(); } catch(e){ console.error('resolve pieces failed', e); }
    initStockfish();

    var defaultAny=null; for (var k in pieceImgResolved) if (pieceImgResolved[k]) { defaultAny = pieceImgResolved[k]; break; }

    function pieceTheme(piece) {
      if (pieceImgResolved && pieceImgResolved[piece]) return pieceImgResolved[piece];
      return defaultAny;
    }

    var config = {
      draggable:true,
      position:'start',
      pieceTheme:pieceTheme,
      moveSpeed:250,
      snapbackSpeed:200,
      snapSpeed:100,
      onDragStart: function(source, piece) {
        // block input when locked
        if (inputLocked) return false;
        try {
          if (game.game_over()) return false;
          if (!piece) return false;
          if ((game.turn()==='w' && piece.search(/^b/)!==-1) || (game.turn()==='b' && piece.search(/^w/)!==-1)) return false;
        } catch (e) {
          console.warn('onDragStart guard triggered', e);
          return false;
        }
      },
      onDrop: function(source, target) {
        if (inputLocked) return 'snapback';
        var move = game.move({from:source, to:target, promotion:'q'});
        if (move === null) { playSound('incorrect'); return 'snapback'; }
        // lock input and start processing
        inputLocked = true;
        doMoveLogic(move, source, target, true);
        return;
      },
      onSnapEnd: function() { board.position(game.fen()); }
    };
    board = Chessboard('myBoard', config);
    setTimeout(function(){ $('#myBoard .chessboard-js-piece').css('transition','top 0.25s, left 0.25s'); }, 1000);
  })();

  // -------------------------
  // sounds/effects/move logic (original)
  // -------------------------
  function playSound(type) {
    var el=null;
    switch(type){
      case 'move': el=document.getElementById('moveSound'); break;
      case 'capture': el=document.getElementById('captureSound'); break;
      case 'promote': el=document.getElementById('promoteSound'); break;
      case 'castling': el=document.getElementById('castlingSound'); break;
      case 'incorrect': el=document.getElementById('incorrectMoveSound'); break;
      case 'check': el=document.getElementById('checkSound'); break;
      case 'checkmate': el=document.getElementById('checkmateSound'); break;
    }
    if (el) { el.currentTime = 0; el.play().catch(()=>{}); }
  }

  function boardMoveEffect(square) {
    var $sq = $('#myBoard .square-' + square);
    $sq.addClass('move-effect');
    setTimeout(function(){ $sq.removeClass('move-effect'); }, 400);
  }

  function playMoveEffectAndSound(move) {
    if (move.flags && (move.flags.includes('k') || move.flags.includes('q'))) playSound('castling');
    else if (move.flags && move.flags.includes('p')) playSound('promote');
    else if (move.flags && (move.flags.includes('c') || move.flags.includes('e'))) playSound('capture');
    else playSound('move');
    if (game.in_checkmate()) playSound('checkmate');
    else if (game.in_check()) playSound('check');
  }

  // core: robust doMoveLogic with locks and guaranteed unlock (original)
  async function doMoveLogic(move, source, target, isDrag) {
    if (processingMove) { console.warn('doMoveLogic re-entry blocked'); return; }
    processingMove = true;
    try {
      playMoveEffectAndSound(move);
      boardMoveEffect(source);
      boardMoveEffect(target);
      globalSum = evaluateBoard(game, move, globalSum, 'b');

      if (!isDrag) board.position(game.fen());

      clearHighlights();
      selectedSquare = null;

      // allow small delay for UI to settle, then compute bot move
      await new Promise(r => setTimeout(r, 300));

      if (game.game_over() || game.turn() !== 'b') {
        // unlock input (game may be over or not bot's turn)
        inputLocked = false;
        processingMove = false;
        return;
      }

      // prefer stockfish if ready
      if (aiMode === 'stockfish' && stockfishEngine && engineReady) {
        try {
          var fen = game.fen();
          console.log('Requesting SF bestmove for fen:', fen);
          var best = await stockfishBestMove(fen, stockfishMovetime).catch(function(e){ console.warn('SF query failed:', e); return null; });
          console.log('Stockfish answered bestmove:', best);

          if (best && best !== '(none)') {
            var from = best.slice(0,2);
            var to = best.slice(2,4);
            var promotion = (best.length > 4) ? best[4] : null;

            // Validate against legal moves
            var legals = game.moves({ verbose: true });
            var matched = null;
            for (var i = 0; i < legals.length; i++) {
              var m = legals[i];
              if (m.from === from && m.to === to) {
                if (promotion) {
                  if (m.promotion && m.promotion === promotion.toLowerCase()) { matched = m; break; }
                } else { matched = m; break; }
              }
            }

            if (matched) {
              console.log('Applying SF move (validated):', matched);
              var botMove = game.move({ from: matched.from, to: matched.to, promotion: matched.promotion || 'q' });
              if (botMove) {
                playMoveEffectAndSound(botMove);
                boardMoveEffect(botMove.from);
                boardMoveEffect(botMove.to);
                globalSum = evaluateBoard(game, botMove, globalSum, 'b');
                board.position(game.fen());
                inputLocked = false; // unlock after bot move applied
                processingMove = false;
                return;
              } else {
                console.warn('game.move returned null despite matched legal move:', matched);
              }
            } else {
              console.warn('Stockfish suggested move not found in legal moves:', best);
            }
          } else {
            console.warn('Stockfish returned no usable bestmove:', best);
          }
        } catch (e) {
          console.warn('Stockfish error during move apply -> fallback to minimax', e);
        }
      }

      // fallback minimax
      if (!game.game_over() && game.turn() === 'b') {
        var botMove = getBestMoveMinimax(game, 'b', globalSum);
        if (botMove) {
          game.move(botMove);
          playMoveEffectAndSound(botMove);
          boardMoveEffect(botMove.from);
          boardMoveEffect(botMove.to);
          globalSum = evaluateBoard(game, botMove, globalSum, 'b');
          board.position(game.fen());
        } else {
          console.warn('Minimax did not return move — position may be terminal.');
        }
      }

      // unlock input finally
      inputLocked = false;
    } finally {
      processingMove = false;
    }
  }

  // -------------------------
  // click-to-move handlers (respect inputLocked)
  // -------------------------
  var selectedSquare = null;
  var legalTargets = [];

  function clearHighlights() { $('#myBoard .square-55d63').removeClass('highlight-click highlight-target'); }
  function highlightSquares(squares, cls){ squares.forEach(function(sq){ $('#myBoard .square-' + sq).addClass(cls); }); }

  $('#myBoard').on('click', '.square-55d63', function() {
    if (inputLocked) return; // ignore clicks while locked
    var square = $(this).attr('data-square');
    if (game.game_over()) return;
    if (!selectedSquare) {
      var piece = game.get(square);
      if (!piece || piece.color !== game.turn()) return;
      selectedSquare = square;
      clearHighlights();
      $('#myBoard .square-' + square).addClass('highlight-click');
      var moves = game.moves({ square: square, verbose: true });
      legalTargets = moves.map(function(m){ return m.to; });
      highlightSquares(legalTargets, 'highlight-target');
    } else {
      if (square === selectedSquare) { selectedSquare = null; legalTargets = []; clearHighlights(); return; }
      if (legalTargets.includes(square)) {
        var move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
        if (move === null) { playSound('incorrect'); clearHighlights(); selectedSquare=null; legalTargets=[]; board.position(game.fen()); return; }
        // lock input and process
        inputLocked = true;
        doMoveLogic(move, selectedSquare, square, false);
        return;
      }
      var piece2 = game.get(square);
      if (piece2 && piece2.color === game.turn()) {
        selectedSquare = square;
        clearHighlights();
        $('#myBoard .square-' + square).addClass('highlight-click');
        var moves = game.moves({ square: square, verbose: true });
        legalTargets = moves.map(function(m){ return m.to; });
        highlightSquares(legalTargets, 'highlight-target');
        return;
      }
      selectedSquare = null; legalTargets = []; clearHighlights();
    }
  });

  $(document).on('click', function(e){ if ($(e.target).closest('#myBoard').length === 0) { clearHighlights(); selectedSquare=null; legalTargets=[]; } });
  $('#myBoard').on('mousedown', '.square-55d63', function(){ clearHighlights(); selectedSquare=null; legalTargets=[]; });

  // init high-level
  </script>

  <!-- ===========================
       === ANALYSIS UPGRADE SCRIPT ===
       =========================== -->
  <script>
  // Analysis state
  var analysisBoard = null;
  var analysisGame = null;
  var analysisPositions = []; // fen per half-move (pos0=start)
  var analysisMoves = [];     // per half-move: {san, from, to, color, evalAfter, evalBestAfter, cpl, tagObj}
  var currentIndex = 0;
  var analysisRunning = false;
  var analysisStopRequested = false;
  var ANALYSIS_MOVETIME = null; // computed from engineOpts
  var chart = null;

  // small util
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // Initialize analysis board (non-draggable)
  function initAnalysisBoard() {
    if (analysisBoard) return;
    var defaultAny=null; for (var k in pieceImgResolved) if (pieceImgResolved[k]) { defaultAny = pieceImgResolved[k]; break; }
    function pieceTheme(piece) {
      if (pieceImgResolved && pieceImgResolved[piece]) return pieceImgResolved[piece];
      return defaultAny;
    }
    analysisBoard = Chessboard('analysisBoard', {
      draggable:false,
      position:'start',
      pieceTheme: pieceTheme,
      moveSpeed: 200
    });
  }

  // Improved stockfish eval: returns last CP (or null). Uses engineBusy guard.
  async function stockfishEval(fen, movetimeMs) {
    if (!stockfishEngine || !engineReady) throw 'engine not ready';
    // wait until engine not busy
    var wc=0;
    while(engineBusy && wc<200){ await sleep(20); wc++; }
    if (engineBusy) throw 'engine busy';
    engineBusy = true;
    return new Promise(function(resolve,reject){
      var prev = stockfishEngine.onmessage;
      var lastCP = null;
      var timeoutId = null;
      var handler = function(ev){
        var line = textFromEvent(ev).trim();
        if (!line) return;
        var mcp = line.match(/score cp (-?\d+)/);
        var mmate = line.match(/score mate (-?\d+)/);
        if (mcp) lastCP = parseInt(mcp[1],10);
        else if (mmate) {
          var mt = parseInt(mmate[1],10);
          lastCP = (mt>0)? (100000 - mt) : (-100000 - mt);
        }
        if (line.indexOf('bestmove') === 0) {
          try {
            stockfishEngine.onmessage = prev;
            if (timeoutId) clearTimeout(timeoutId);
            engineBusy = false;
            resolve(lastCP);
          } catch(e) {
            try { stockfishEngine.onmessage = prev; } catch(e){}
            if (timeoutId) clearTimeout(timeoutId);
            engineBusy = false;
            reject(e);
          }
        }
      };
      try {
        stockfishEngine.onmessage = handler;
        stockfishEngine.postMessage('position fen ' + fen);
        stockfishEngine.postMessage('go movetime ' + parseInt(movetimeMs,10));
      } catch(e){
        try { stockfishEngine.onmessage = prev; } catch(e){}
        engineBusy = false;
        reject(e);
      }
      timeoutId = setTimeout(function(){
        try { stockfishEngine.onmessage = prev; } catch(e){}
        engineBusy = false;
        resolve(lastCP);
      }, Math.max(8000, movetimeMs + 4000));
    });
  }

  // get bestmove for a fen (string), returns {best, score}
  async function stockfishBestMoveWithInfo(fen, movetimeMs) {
    if (!stockfishEngine || !engineReady) throw 'engine not ready';
    var wc=0;
    while(engineBusy && wc<200){ await sleep(20); wc++; }
    if (engineBusy) throw 'engine busy';
    engineBusy = true;
    return new Promise(function(resolve,reject){
      var prev = stockfishEngine.onmessage;
      var lastCP = null;
      var timeoutId = null;
      var lastBest = null;
      var handler = function(ev){
        var line = textFromEvent(ev).trim();
        if (!line) return;
        var mcp = line.match(/score cp (-?\d+)/);
        var mmate = line.match(/score mate (-?\d+)/);
        if (mcp) lastCP = parseInt(mcp[1],10);
        else if (mmate) {
          var mt = parseInt(mmate[1],10);
          lastCP = (mt>0)? (100000 - mt) : (-100000 - mt);
        }
        if (line.indexOf('bestmove') === 0) {
          try {
            var parts = line.split(/\s+/);
            lastBest = parts[1];
            stockfishEngine.onmessage = prev;
            if (timeoutId) clearTimeout(timeoutId);
            engineBusy = false;
            resolve({best: lastBest, score: lastCP});
          } catch(e) {
            try { stockfishEngine.onmessage = prev; } catch(e){}
            if (timeoutId) clearTimeout(timeoutId);
            engineBusy = false;
            reject(e);
          }
        }
      };
      try {
        stockfishEngine.onmessage = handler;
        stockfishEngine.postMessage('position fen ' + fen);
        stockfishEngine.postMessage('go movetime ' + parseInt(movetimeMs,10));
      } catch(e){
        try { stockfishEngine.onmessage = prev; } catch(e){}
        engineBusy = false;
        reject(e);
      }
      timeoutId = setTimeout(function(){
        try { stockfishEngine.onmessage = prev; } catch(e){}
        engineBusy = false;
        resolve({best: lastBest, score: lastCP});
      }, Math.max(8000, movetimeMs + 4000));
    });
  }

  // helper: detect mate-coded scores
  function isMateScore(score) {
    return (typeof score === 'number') && Math.abs(score) > 90000;
  }
  function mateDistance(score) {
    if (!isMateScore(score)) return null;
    return 100000 - Math.abs(score); // smaller => quicker mate
  }
  function normalizeMoveStr(mvStr) { if (!mvStr) return ''; return mvStr.replace(/\s+/g,'').toLowerCase(); }
  function playedMoveToStr(moveObj) { return (moveObj.from || '') + (moveObj.to || '') + ((moveObj.promotion||'') ); }

  // Detailed classifier: returns {tag, cls, reason, cpl}
  function classifyMoveDetailed(mvIndex, mv, bestObj, evalBefore, evalBestAfter, evalAfter, pgnHeaders) {
    var playedStr = normalizeMoveStr(playedMoveToStr(mv));
    var bestStr = bestObj && bestObj.best ? normalizeMoveStr(bestObj.best) : null;
    var moverColor = mv && mv.color ? mv.color : 'w';

    // CPL: positive -> player lost cp vs engine-best
    function computeCPL_local(evalBest, evalPlayed, color) {
      if (typeof evalBest !== 'number' || typeof evalPlayed !== 'number') return null;
      var sign = (color === 'w') ? 1 : -1;
      return sign * (evalBest - evalPlayed);
    }
    var cpl = computeCPL_local(evalBestAfter, evalAfter, moverColor);

    // deltaFromBefore: positive => mover improved compared to before
    var deltaFromBefore = null;
    if (typeof evalBefore === 'number' && typeof evalAfter === 'number') {
      deltaFromBefore = (moverColor === 'w') ? (evalAfter - evalBefore) : (evalBefore - evalAfter);
    }

    // Book heuristic
    var isBook = false;
    if (pgnHeaders && (pgnHeaders.ECO || pgnHeaders.Opening)) {
      if (typeof mvIndex === 'number' && mvIndex <= 16) {
        if ((typeof evalBefore !== 'number' || Math.abs(evalBefore) <= 30) &&
            (typeof evalAfter !== 'number' || Math.abs(evalAfter) <= 30)) {
          isBook = true;
        }
      }
    }

    // 1) direct mate by player
    if (isMateScore(evalAfter)) {
      if ((moverColor === 'w' && evalAfter > 0) || (moverColor === 'b' && evalAfter < 0)) {
        return { tag:'Brilliant', cls:'tag brilliant', reason:'direct mate', cpl: cpl };
      }
    }

    // 2) if played move equals engine best
    var isBestMove = (bestStr && playedStr && bestStr === playedStr);
    if (isBestMove) {
      if (deltaFromBefore !== null) {
        if (deltaFromBefore >= 200) return { tag:'Brilliant', cls:'tag brilliant', reason:'best move with huge improvement', cpl: cpl };
        if (deltaFromBefore >= 100) return { tag:'Great', cls:'tag great', reason:'best move with clear improvement', cpl: cpl };
        if (deltaFromBefore >= 50)  return { tag:'Excellent', cls:'tag excellent', reason:'best move with modest improvement', cpl: cpl };
        return { tag:'Best', cls:'tag best', reason:'engine-best move', cpl: cpl };
      } else {
        return { tag:'Best', cls:'tag best', reason:'engine-best move', cpl: cpl };
      }
    }

    // 3) engine had mate but player missed -> Miss
    if (bestObj && isMateScore(bestObj.score)) {
      return { tag:'Miss', cls:'tag miss', reason:'missed engine mate', cpl: cpl };
    }

    // 4) CPL-based classification (player worse than engine-best)
    if (typeof cpl === 'number') {
      if (cpl >= 300) return { tag:'Blunder', cls:'tag blunder', reason:'very large centipawn loss vs engine-best', cpl: cpl };
      if (cpl >= 150) return { tag:'Miss', cls:'tag miss', reason:'serious tactical miss', cpl: cpl };
      if (cpl >= 100) return { tag:'Mistake', cls:'tag mistake', reason:'clear mistake', cpl: cpl };
      if (cpl >= 50) return { tag:'Inaccuracy', cls:'tag inacc', reason:'inaccuracy', cpl: cpl };
      if (Math.abs(cpl) < 50) return { tag:'Good', cls:'tag good', reason:'small/no difference vs engine-best', cpl: cpl };
      // negative CPL (player did better than engine expected)
      if (cpl <= -300) return { tag:'Brilliant', cls:'tag brilliant', reason:'huge improvement vs engine expectation', cpl: cpl };
      if (cpl <= -150) return { tag:'Great', cls:'tag great', reason:'big improvement vs engine expectation', cpl: cpl };
      if (cpl <= -50) return { tag:'Excellent', cls:'tag excellent', reason:'good move beyond expectation', cpl: cpl };
    }

    // 5) Book fallback
    if (isBook) return { tag:'Book', cls:'tag book', reason:'opening book (heuristic)', cpl: cpl };

    // 6) fallback
    return { tag:'Good', cls:'tag good', reason:'default/good', cpl: cpl };
  }

  // compute CPL given evals (evalAfterBest, evalAfterPlayed), and mover color (kept for compatibility)
  function computeCPL(evalAfterBest, evalAfterPlayed, color) {
    if (typeof evalAfterBest !== 'number' || typeof evalAfterPlayed !== 'number') return null;
    var sign = (color === 'w') ? 1 : -1;
    var cpl = sign * (evalAfterBest - evalAfterPlayed);
    return cpl;
  }

  // Update eval bar UI (score in centipawns, positive => White advantage)
  function updateEvalBar(score) {
    if (typeof score !== 'number') score = 0;
    var clamped = Math.max(-2000, Math.min(2000, score));
    var percent = ((clamped + 2000) / 4000) * 100; // 0..100
    $('#evalFill').css('height', percent + '%');
    if (percent > 55) $('#evalFill').css('background','linear-gradient(#fff59d,#ffd54f)');
    else if (percent < 45) $('#evalFill').css('background','linear-gradient(#cfe9ff,#90caf9)');
    else $('#evalFill').css('background','linear-gradient(#e6e6e6,#cfcfcf)');
  }

  // Chart setup: three datasets (overall eval, white moves, black moves)
  function initChart() {
    var ctx = document.getElementById('moveEvalChart').getContext('2d');
    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [], // half-move index starting 1...
        datasets: [
          { label:'Eval', data: [], borderColor:'#9aa4b2', borderWidth:1, pointRadius:0, tension:0.25, fill:false },
          { label:'White', data: [], borderColor:'#58a6ff', backgroundColor:'#58a6ff', borderWidth:2, pointRadius:3, tension:0.2, fill:false },
          { label:'Black', data: [], borderColor:'#ffb86b', backgroundColor:'#ffb86b', borderWidth:2, pointRadius:3, tension:0.2, fill:false }
        ]
      },
      options: {
        scales: {
          x:{ title:{display:true, text:'Half-move index'}},
          y:{ title:{display:true, text:'Evaluation (centipawns)'}, ticks:{ stepSize:100 } }
        },
        plugins: { legend:{ display:true, labels:{ color:'#cbd5e1' } }, tooltip:{ mode:'index', intersect:false } },
        interaction: { mode:'index', intersect:false },
        responsive:true,
        maintainAspectRatio:false
      }
    });
  }

  // Append move rows to PGN table
  function renderMovesTable() {
    var $tb = $('#pgnMoveTable tbody');
    $tb.empty();
    for (var i=0;i<Math.ceil(analysisMoves.length/2);i++){
      var w = analysisMoves[2*i] || null;
      var b = analysisMoves[2*i+1] || null;
      var tr = $('<tr>').attr('data-move', i+1);
      tr.append($('<td>').text(i+1));
      var tdW = $('<td>').text(w ? w.san : '');
      var tdWTag = $('<td>');
      if (w && w.tagObj) tdWTag.html('<span class="'+w.tagObj.cls+'">'+w.tagObj.tag+'</span>');
      var tdB = $('<td>').text(b ? b.san : '');
      var tdBTag = $('<td>');
      if (b && b.tagObj) tdBTag.html('<span class="'+b.tagObj.cls+'">'+b.tagObj.tag+'</span>');
      tr.append(tdW).append(tdWTag).append(tdB).append(tdBTag);
      $tb.append(tr);
    }
  }

  // Set analysis position by half-move index (0 = start)
  function setAnalysisPosition(idx) {
    if (!analysisPositions[idx]) return;
    currentIndex = idx;
    analysisBoard.position(analysisPositions[idx]);
    // update eval bar using evalAfter of last move (idx-1)
    var last = analysisMoves[idx-1] || null;
    var evalToShow = (last && typeof last.evalAfter === 'number') ? last.evalAfter : 0;
    updateEvalBar(evalToShow);
    // highlight table row
    $('#pgnMoveTable tbody tr').removeClass('table-active');
    if (idx>0) {
      var pair = Math.ceil(idx/2);
      $('#pgnMoveTable tbody tr[data-move="'+pair+'"]').addClass('table-active');
    }
  }

  // Undo/Redo handlers for analysis board
  $('#undoMove').on('click', function(){
    if (currentIndex>0) setAnalysisPosition(currentIndex-1);
  });
  $('#redoMove').on('click', function(){
    if (currentIndex < analysisPositions.length-1) setAnalysisPosition(currentIndex+1);
  });

  // Click row to jump
  $('#pgnMoveTable').on('click','tbody tr', function(){
    var mv = parseInt($(this).attr('data-move'),10);
    if (isNaN(mv)) return;
    // go to end of that pair (half index = mv*2)
    var half = Math.min(analysisPositions.length-1, mv*2);
    setAnalysisPosition(half);
  });

  // Analyze PGN workflow (upgraded to use classifyMoveDetailed)
  async function analyzePGN(pgn) {
    try {
      analysisRunning = true;
      analysisStopRequested = false;
      $('#stopAnalysis').prop('disabled', false);
      $('#loadPGN').prop('disabled', true);
      $('#analysisProgress').removeClass('bg-success bg-warning').css('width','0%').text('0%');

      initAnalysisBoard();
      initChart();

      analysisGame = new Chess();
      var ok = analysisGame.load_pgn(pgn);
      if (!ok) {
        // try extracting moves-only
        var movesOnly = pgn.replace(/\[.*\]\s*/g,'').trim();
        if (!analysisGame.load_pgn(movesOnly)) {
          alert('Unable to parse PGN — make sure format is standard.');
          analysisRunning = false;
          $('#stopAnalysis').prop('disabled', true);
          $('#loadPGN').prop('disabled', false);
          return;
        }
      }

      // parse headers for usernames
      function headerVal(key) {
        var m = pgn.match(new RegExp('\\['+key+'\\s+"([^"]+)"','i'));
        return m ? m[1] : '';
      }
      var wName = headerVal('White') || 'White';
      var bName = headerVal('Black') || 'Black';
      $('#whiteName').text('White: ' + wName);
      $('#blackName').text('Black: ' + bName);

      // prepare
      var verbose = analysisGame.history({verbose:true});
      analysisGame.reset();
      analysisPositions = [ analysisGame.fen() ];
      analysisMoves = [];
      currentIndex = 0;

      // compute analysis movetime based on hwc
      var opts = computeEngineOptions();
      ANALYSIS_MOVETIME = Math.max(350, (opts.hwc >= 8 ? 900 : 600)); // conservative
      // you can tune ANALYSIS_MOVETIME for speed vs quality

      // prepare chart arrays
      var labels = [];
      var evalTotal = [];
      var evalWhite = [];
      var evalBlack = [];

      for (var i=0;i<verbose.length;i++) {
        if (analysisStopRequested) break;

        var mv = verbose[i]; // {color, from, to, piece, san, ...}
        var fenBefore = analysisGame.fen();

        // --- NEW: compute evalBefore for better classification (small movetime)
        var evalBefore = null;
        try {
          evalBefore = await stockfishEval(fenBefore, Math.max(200, Math.floor(ANALYSIS_MOVETIME/3)));
        } catch(e) {
          evalBefore = null;
        }

        // 1) request engine's bestmove at fenBefore
        var bestObj = null;
        try {
          bestObj = await stockfishBestMoveWithInfo(fenBefore, ANALYSIS_MOVETIME);
        } catch(e){
          console.warn('bestmove failed', e);
          // fallback to quick bestmove
          try { var b = await stockfishBestMove(fenBefore, Math.max(300, Math.floor(ANALYSIS_MOVETIME/2))); bestObj = {best:b, score:null}; } catch(e2){ bestObj = {best:null, score:null}; }
        }

        // 2) compute fen after best (if exists)
        var fenAfterBest = null;
        if (bestObj && bestObj.best) {
          var tmp = new Chess();
          tmp.load(fenBefore);
          try { tmp.move({from:bestObj.best.slice(0,2), to:bestObj.best.slice(2,4), promotion: (bestObj.best.length>4 ? bestObj.best[4] : 'q')}); fenAfterBest = tmp.fen(); } catch(e) { fenAfterBest = null; }
        }

        // 3) evaluate fenAfterBest
        var evalBestAfter = null;
        if (fenAfterBest) {
          try { evalBestAfter = await stockfishEval(fenAfterBest, Math.max(300, ANALYSIS_MOVETIME)); } catch(e){ evalBestAfter = null; }
        }

        // 4) apply actual move
        analysisGame.move({from:mv.from, to:mv.to, promotion: mv.promotion || 'q'});
        var fenAfter = analysisGame.fen();

        // 5) evaluate fenAfter
        var evalAfter = null;
        try { evalAfter = await stockfishEval(fenAfter, Math.max(300, ANALYSIS_MOVETIME)); } catch(e){ evalAfter = null; }

        // 6) compute CPL (kept)
        var cpl = computeCPL(evalBestAfter, evalAfter, mv.color);

        // 7) NEW: use detailed classifier
        var headersObj = { ECO: headerVal('ECO'), Opening: headerVal('Opening') };
        var tagObj = classifyMoveDetailed(i+1, mv, bestObj, evalBefore, evalBestAfter, evalAfter, headersObj);

        // store move entry
        analysisMoves.push({
          san: mv.san || (mv.from + mv.to),
          from: mv.from, to: mv.to, color: mv.color,
          evalAfter: (typeof evalAfter === 'number')? evalAfter : null,
          evalBestAfter: (typeof evalBestAfter === 'number')? evalBestAfter : null,
          cpl: (typeof cpl === 'number')? Math.round(cpl) : null,
          tagObj: tagObj
        });

        // store fen
        analysisPositions.push(fenAfter);

        // chart arrays (half-move index = i+1)
        labels.push(i+1);
        var val = (typeof evalAfter === 'number')? evalAfter : 0;
        evalTotal.push(val);
        if (mv.color === 'w') { evalWhite.push(val); evalBlack.push(null); }
        else { evalBlack.push(val); evalWhite.push(null); }

        // update progress UI
        var pct = Math.round(((i+1)/verbose.length) * 100);
        $('#analysisProgress').css('width', pct + '%').text(pct + '%');

        // small breathing room
        await sleep(80);
      } // end for

      // done or stopped
      analysisRunning = false;
      $('#stopAnalysis').prop('disabled', true);
      $('#loadPGN').prop('disabled', false);
      if (analysisStopRequested) $('#analysisProgress').addClass('bg-warning'); else $('#analysisProgress').addClass('bg-success');

      // render table and chart
      renderMovesTable();
      initAnalysisBoard();
      setAnalysisPosition(0);

      // populate chart dataset
      if (chart) {
        chart.data.labels = labels;
        chart.data.datasets[0].data = evalTotal;
        chart.data.datasets[1].data = evalWhite;
        chart.data.datasets[2].data = evalBlack;
        chart.update();
      }

      // enable undo/redo
      $('#undoMove').prop('disabled', false);
      $('#redoMove').prop('disabled', false);
    } catch(e){
      console.error('analyzePGN error', e);
      alert('Error during analysis: ' + e);
      analysisRunning = false;
      $('#stopAnalysis').prop('disabled', true);
      $('#loadPGN').prop('disabled', false);
    }
  }

  // UI bindings
  $('#btnAnalysis').on('click', function(){
    $('#humanPanel').hide();
    $('#analysisSection').show();
    initAnalysisBoard();
    initChart();
    // auto-fill sample PGN if empty
    var sample = `[Event "Live Chess"]
[Site "Chess.com"]
[Date "2025.09.09"]
[Round "?"]
[White "Rafsangrandmaster"]
[Black "Bachduy86"]
[Result "1-0"]
[TimeControl "600"]
[WhiteElo "1235"]
[BlackElo "1228"]
[Termination "Rafsangrandmaster won - game abandoned"]
[ECO "D02"]
[EndTime "8:40:33 GMT+0000"]
[Link "https://www.chess.com/game/live/142906592730"]

1. d4 e6 2. Nf3 d5 3. Bf4 Nf6 4. e3 1-0`;
    if (!$('#pgnInput').val().trim()) $('#pgnInput').val(sample);
  });
  $('#btnHumanBot, #backBtn').on('click', function(){
    $('#analysisSection').hide();
    $('#humanPanel').show();
  });

  $('#stopAnalysis').on('click', function(){
    if (!analysisRunning) return;
    analysisStopRequested = true;
    $('#stopAnalysis').prop('disabled', true);
  });

  $('#loadPGN').on('click', async function(){
    var pgn = $('#pgnInput').val().trim();
    if (!pgn) { alert('Paste PGN first'); return; }
    // reset UI
    $('#pgnMoveTable tbody').empty();
    initAnalysisBoard();
    initChart();
    analysisPositions = [];
    analysisMoves = [];
    currentIndex = 0;
    await analyzePGN(pgn);
  });

  // init
  $(function(){
    initAnalysisBoard();
    initChart();
    // resolve pieces asap
    resolveAllPieces().catch(()=>{});
  });

  </script>
</body>
</html>
