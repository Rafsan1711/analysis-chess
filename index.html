<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chess Bot + Stockfish — Stable (Improved Eval, PGN, Captures)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" crossorigin="anonymous">
  <style>
    /* ---------- base ---------- */
    :root{
      --bg: #hsl(60deg 2.7% 14.51%);
      --card: #ffffff;
      --muted: #6b7280;
      --accent: linear-gradient(180deg,#56ccf2,#2f80ed);
      --good: #22c55e;
      --bad: #ef4444;
    }
    body { background:var(--bg); font-family: Inter, system-ui, Arial, sans-serif; margin:0; padding:18px; color:#0f172a; }
    .wrap { max-width:1100px; margin:0 auto; }

    /* layout */
    .main-row { display:flex; gap:14px; align-items:flex-start; }
    .left-col { width:72px; display:flex; justify-content:center; }
    .center-col { flex:1; display:flex; flex-direction:column; gap:12px; }
    .right-col { width:260px; min-width:200px; }

    /* board card */
    .card { background:var(--card); border-radius:12px; box-shadow: 0 10px 30px rgba(16,24,40,0.06); padding:12px; }
    .board-card { display:flex; gap:12px; align-items:flex-start; padding:16px; }

    /* eval bar (strictly vertical) */
    .eval-wrap { width:56px; display:flex; flex-direction:column; align-items:center; gap:8px; }
    .eval-track { width:18px; height:420px; background:#f1f5f9; border-radius:12px; position:relative; box-shadow: inset 0 2px 6px rgba(0,0,0,0.04); overflow:hidden; }
    .eval-fill {
      position:absolute; left:0; right:0; bottom:0;
      height:50%;
      border-radius:12px 12px 0 0;
      transition:height 300ms ease, background 300ms ease;
      background: linear-gradient(180deg,#2ecc71,#16a34a);
    }
    .eval-fill.black { background: linear-gradient(0deg,#f97316,#ef4444); } /* black advantage */
    .eval-label { font-size:13px; color:var(--muted); text-align:center; width:72px; word-break:normal; }

    /* board area */
    .board-area { display:flex; flex-direction:column; align-items:center; gap:8px; }
    #myBoard { width:100%; max-width:520px; min-width:260px; min-height:340px; }
    #engineStatus { font-size:13px; color:var(--muted); margin-top:4px; text-align:center; }

    /* captures */
    .captures-row { display:flex; justify-content:space-between; width:100%; gap:12px; }
    .captures-card { flex:1; display:flex; align-items:center; gap:10px; padding:6px 10px; border-radius:10px; background:#f8fafc; border:1px solid rgba(15,23,42,0.03); }
    .captures-list img { width:20px; height:20px; margin-right:6px; display:inline-block; object-fit:contain; }
    .captures-adv { font-weight:700; font-size:13px; color:#0f172a; margin-left:auto; }

    /* PGN table */
    .pgn-card { width:100%; padding:12px; border-radius:10px; background:linear-gradient(180deg,#ffffff,#fbfdff); box-shadow:0 6px 18px rgba(2,6,23,0.04); }
    .pgn-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; gap:8px; }
    .pgn-title { font-weight:700; font-size:15px; color:#0b1220; }
    .pgn-controls { display:flex; gap:8px; align-items:center; }
    .btn { border:0; padding:8px 10px; border-radius:8px; background:#0f172a; color:white; cursor:pointer; font-size:13px; }
    .btn.ghost { background:transparent; color:var(--muted); border:1px solid rgba(2,6,23,0.06); }
    .pgn-table-wrap { max-height:260px; overflow:auto; border-radius:8px; border:1px solid rgba(2,6,23,0.04); }
    table.pgn-table { width:100%; border-collapse:collapse; min-width:420px; }
    table.pgn-table thead th { position:sticky; top:0; background:#fff; padding:10px 12px; text-align:left; font-size:13px; color:var(--muted); border-bottom:1px solid rgba(2,6,23,0.04); z-index:2; }
    table.pgn-table td { padding:10px 12px; border-bottom:1px dashed rgba(2,6,23,0.03); font-size:14px; color:#0b1220; }
    table.pgn-table tr:nth-child(even){ background: rgba(15,23,42,0.02); }
    td.move-num { width:48px; color:var(--muted); font-weight:700; }

    /* right column controls */
    .side-panel { display:flex; flex-direction:column; gap:10px; }
    .panel-item { padding:10px; border-radius:8px; background:#fff; border:1px solid rgba(2,6,23,0.04); }
    .small { font-size:13px; color:var(--muted); }

    /* highlights and piece transitions */
    .highlight-click { box-shadow:0 0 8px 4px rgba(249,115,22,0.22) inset; }
    .highlight-target { box-shadow:0 0 4px 2px rgba(34,197,94,0.18) inset; }
    .move-effect { animation: boardMoveEffect 0.38s; }
    @keyframes boardMoveEffect { 0% { box-shadow:0 0 10px 6px rgba(51,221,51,0.14) inset;} 100% { box-shadow:none; } }
    .chessboard-js-piece { transition: top 0.25s, left 0.25s; z-index: 10; }

    /* responsive keep eval vertical */
    @media (max-width:900px){
      .main-row { flex-direction:column; gap:10px; }
      .left-col { width:100%; display:flex; justify-content:center; }
      .right-col { width:100%; }
      .eval-track { height:300px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="main-row">
      <!-- Evaluation bar (strict vertical) -->
      <div class="left-col">
        <div class="eval-wrap card" aria-hidden="true">
          <div style="font-size:13px; font-weight:700; color:#0b1220;">Eval</div>
          <div class="eval-track" id="evalTrack">
            <div class="eval-fill" id="evalFill" style="height:50%"></div>
          </div>
          <div class="eval-label" id="evalLabel">0 cp</div>
        </div>
      </div>

      <!-- Center: board + captures + pgn -->
      <div class="center-col">
        <div class="card board-card" style="align-items:flex-start;">
          <div style="flex:1; display:flex; flex-direction:column; gap:8px; width:100%; align-items:center;">
            <div class="captures-row" style="width:100%;">
              <div class="captures-card" id="whiteCapturesCard">
                <div style="font-size:13px; color:#0b1220; min-width:80px;">White captured</div>
                <div class="captures-list" id="whiteCapturesList"></div>
                <div class="captures-adv" id="whiteAdvBadge"></div>
              </div>
              <div class="captures-card" id="blackCapturesCard">
                <div style="font-size:13px; color:#0b1220; min-width:80px;">Black captured</div>
                <div class="captures-list" id="blackCapturesList"></div>
                <div class="captures-adv" id="blackAdvBadge"></div>
              </div>
            </div>

            <div id="myBoard"></div>
            <div id="engineStatus">Engine: initializing...</div>
          </div>
        </div>

        <div class="pgn-card card">
          <div class="pgn-header">
            <div class="pgn-title">Moves (PGN)</div>
            <div class="pgn-controls">
              <button class="btn" id="copyPgnBtn">Copy PGN</button>
              <button class="btn ghost" id="resetBtn">Reset</button>
            </div>
          </div>
          <div class="pgn-table-wrap">
            <table class="pgn-table" id="pgnTable">
              <thead>
                <tr>
                  <th style="width:56px">#</th>
                  <th>White</th>
                  <th>Black</th>
                </tr>
              </thead>
              <tbody id="pgnBody"></tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- Right: small controls -->
      <div class="right-col">
        <div class="side-panel">
          <div class="panel-item">
            <div style="font-weight:700;">Engine</div>
            <div style="margin-top:8px;">
              <select id="engineMode" style="width:100%; padding:8px; border-radius:6px; border:1px solid rgba(2,6,23,0.06);">
                <option value="stockfish">Stockfish</option>
                <option value="minimax">Minimax</option>
              </select>
            </div>
            <div style="margin-top:8px;" class="small">Threads: <span id="hwThreads">-</span></div>
          </div>

          <div class="panel-item">
            <div style="font-weight:700;">Info</div>
            <div style="margin-top:8px;" class="small">Material diff (white - black): <span id="matDiff">0</span></div>
            <div style="margin-top:6px;" class="small">Stockfish movetime (ms): <span id="movetimeDisplay">800</span></div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <!-- Sounds -->
  <audio id="moveSound" src="sounds/move.mp3"></audio>
  <audio id="captureSound" src="sounds/capture.mp3"></audio>
  <audio id="promoteSound" src="sounds/promote.mp3"></audio>
  <audio id="castlingSound" src="sounds/castling.mp3"></audio>
  <audio id="incorrectMoveSound" src="sounds/incorrect-move.mp3"></audio>
  <audio id="checkSound" src="sounds/check.mp3"></audio>
  <audio id="checkmateSound" src="sounds/checkmate.mp3"></audio>

  <!-- libs (unchanged) -->
  <script src="https://code.jquery.com/jquery-3.5.1.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js" crossorigin="anonymous"></script>
  <script src="js/chess.js"></script>

  <script>
  // -------------------------
  // piece resolver (unchanged)
  // -------------------------
  var pieceCandidates = {
    'wK':['pieces/wK.svg','pieces/wKing.svg','pieces/WK.svg'],
    'wQ':['pieces/wQ.svg','pieces/wQueen.svg','pieces/WQ.svg'],
    'wR':['pieces/wR.svg','pieces/wRook.svg','pieces/WR.svg'],
    'wB':['pieces/wB.svg','pieces/wBishop.svg','pieces/WB.svg'],
    'wN':['pieces/wN.svg','pieces/wKnight.svg','pieces/WN.svg','pieces/wn.svg'],
    'wP':['pieces/wP.svg','pieces/wPawn.svg','pieces/WP.svg'],
    'bK':['pieces/bK.svg','pieces/bKing.svg','pieces/BK.svg'],
    'bQ':['pieces/bQ.svg','pieces/bQueen.svg','pieces/BQ.svg'],
    'bR':['pieces/bR.svg','pieces/bRook.svg','pieces/BR.svg'],
    'bB':['pieces/bB.svg','pieces/bBishop.svg','pieces/BB.svg'],
    'bN':['pieces/bN.svg','pieces/bKnight.svg','pieces/BN.svg','pieces/bn.svg','pieces/black-knight.svg'],
    'bP':['pieces/bP.svg','pieces/bPawn.svg','pieces/BP.svg']
  };
  var pieceImgResolved = {};

  function loadImage(url){ return new Promise(function(resolve,reject){ var img=new Image(); img.onload=function(){resolve(url)}; img.onerror=function(){reject(url)}; img.src=url; }); }
  async function resolvePiece(key, candidates){
    for (var i=0;i<candidates.length;i++){
      try{ var ok = await loadImage(candidates[i]); console.log('Loaded piece', key, '->', candidates[i]); return candidates[i]; }
      catch(e){}
    }
    console.warn('No image found for', key, candidates);
    return null;
  }
  async function resolveAllPieces(){
    var keys=Object.keys(pieceCandidates);
    for (var i=0;i<keys.length;i++){ pieceImgResolved[keys[i]] = await resolvePiece(keys[i], pieceCandidates[keys[i]]); }
    if (!pieceImgResolved['bN']) {
      if (pieceImgResolved['wN']) pieceImgResolved['bN'] = pieceImgResolved['wN'];
      else { for (var p in pieceImgResolved) if (pieceImgResolved[p]) { pieceImgResolved['bN'] = pieceImgResolved[p]; break; } }
    }
    var defaultAny=null; for (var k in pieceImgResolved) if (pieceImgResolved[k]) { defaultAny = pieceImgResolved[k]; break; }
    for (var k2 in pieceImgResolved) if (!pieceImgResolved[k2]) pieceImgResolved[k2] = defaultAny;
    console.log('Resolved pieces:', pieceImgResolved);
    return pieceImgResolved;
  }

  // -------------------------
  // engine (Blob worker) + robust handling
  // -------------------------
  var board = null;
  var game = new Chess();
  var globalSum = 0;

  var aiMode = 'stockfish'; // 'stockfish' or 'minimax'
  var stockfishEngine = null;
  var engineReady = false;
  var engineBusy = false;
  var stockfishMovetime = 800;
  var engineOpts = {};
  var engineDefaultHandler = null;

  // captured lists and material points
  var capturedByWhite = []; // black pieces captured by white
  var capturedByBlack = []; // white pieces captured by black
  var materialVals = { p:1, n:3, b:3, r:5, q:9, k:0 };

  // new flags to prevent re-entrancy / overlapping moves
  var inputLocked = false;       // true while user action/bot thinking/applying move
  var processingMove = false;    // true inside doMoveLogic

  function computeEngineOptions(){
    var hwc = navigator.hardwareConcurrency || 2;
    var isMobile = /Mobi|Android/i.test(navigator.userAgent) || (window.innerWidth && window.innerWidth < 720);
    var threads = isMobile ? 1 : Math.min(4, Math.max(1, Math.floor(hwc)));
    var hash = isMobile ? 16 : 64;
    var movetime = isMobile ? 350 : (hwc >= 8 ? 1200 : 800);
    var skill = 20;
    engineOpts = {threads:threads, hash:hash, movetime:movetime, skill:skill, isMobile:isMobile, hwc:hwc};
    stockfishMovetime = movetime;
    document.getElementById('hwThreads').innerText = threads;
    document.getElementById('movetimeDisplay').innerText = stockfishMovetime;
    return engineOpts;
  }

  function createStockfishBlobWorker(cdnUrl) {
    try {
      var blobCode = "importScripts('" + cdnUrl + "');";
      var blob = new Blob([blobCode], {type: 'application/javascript'});
      var blobURL = URL.createObjectURL(blob);
      var w = new Worker(blobURL);
      setTimeout(function(){ URL.revokeObjectURL(blobURL); }, 5000);
      return w;
    } catch (e) {
      console.error('createStockfishBlobWorker failed', e);
      return null;
    }
  }

  function textFromEvent(ev) {
    var d = (ev && ev.data !== undefined) ? ev.data : ev;
    if (typeof d === 'string') return d;
    try { return '' + d; } catch(e){ return String(d); }
  }

  function initStockfish() {
    var opts = computeEngineOptions();
    console.log('Engine options:', opts);
    document.getElementById('engineStatus').innerText = 'Engine: loading...';

    try {
      if (typeof STOCKFISH === 'function') {
        stockfishEngine = STOCKFISH();
      } else {
        var cdn = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
        stockfishEngine = createStockfishBlobWorker(cdn);
      }
    } catch (e) {
      console.warn('Stockfish init attempt failed:', e);
      stockfishEngine = null;
    }

    if (!stockfishEngine) {
      engineReady = false;
      document.getElementById('engineStatus').innerText = 'Engine: unavailable (fallback to minimax)';
      console.warn('Stockfish not available; using minimax fallback.');
      return;
    }

    // default handler extended: parse 'info' lines for score
    engineDefaultHandler = function(ev) {
      var line = textFromEvent(ev).trim();
      if (!line) return;
      // console.log('stockfish:', line);
      if (line.indexOf('readyok') !== -1) {
        engineReady = true;
        document.getElementById('engineStatus').innerText =
          'Engine: ready (Stockfish, threads ' + engineOpts.threads + ', hash ' + engineOpts.hash + 'MB)';
      }
      // parse info lines like: info depth 20 score cp 34 or info depth 30 score mate -3
      if (line.indexOf('info') === 0 && line.indexOf('score') !== -1) {
        try {
          var s = /score\s+(cp|mate)\s+(-?\d+)/.exec(line);
          if (s) {
            var type = s[1], val = parseInt(s[2],10);
            if (type === 'cp') updateEvaluationFromEngine({cp: val});
            else updateEvaluationFromEngine({mate: val});
          }
        } catch (e) { console.warn('parse score fail', e); }
      }
    };

    try {
      stockfishEngine.onmessage = engineDefaultHandler;
      stockfishEngine.postMessage('uci');
      stockfishEngine.postMessage('setoption name Threads value ' + (engineOpts.threads || computeEngineOptions().threads));
      stockfishEngine.postMessage('setoption name Hash value ' + (engineOpts.hash || computeEngineOptions().hash));
      stockfishEngine.postMessage('setoption name Skill Level value ' + (engineOpts.skill || computeEngineOptions().skill));
      stockfishEngine.postMessage('setoption name UCI_LimitStrength value false');
      stockfishEngine.postMessage('isready');
    } catch (e) {
      console.error('Error configuring stockfish:', e);
    }
  }

  // Safe SF query: capture info lines during the search (so eval bar moves), and capture bestmove
  function stockfishBestMove(fen, movetimeMs) {
    return new Promise(function(resolve, reject) {
      if (!stockfishEngine || !engineReady) return reject('engine not ready');
      if (engineBusy) return reject('engine busy');
      engineBusy = true;

      var prevHandler = stockfishEngine.onmessage;
      var timeoutId = null;

      // handler will parse info lines and bestmove
      var capture = function(ev) {
        var line = textFromEvent(ev).trim();
        if (!line) return;
        // parse info score to update eval bar live
        if (line.indexOf('info') === 0 && line.indexOf('score') !== -1) {
          try {
            var s = /score\s+(cp|mate)\s+(-?\d+)/.exec(line);
            if (s) {
              var type = s[1], val = parseInt(s[2],10);
              if (type === 'cp') updateEvaluationFromEngine({cp: val});
              else updateEvaluationFromEngine({mate: val});
            }
          } catch(e){}
        }
        // pick bestmove
        if (line.indexOf('bestmove') === 0) {
          try {
            var parts = line.split(/\s+/);
            var best = parts[1];
            try { stockfishEngine.onmessage = prevHandler; } catch(e) {}
            if (timeoutId) clearTimeout(timeoutId);
            engineBusy = false;
            resolve(best);
          } catch (err) {
            try { stockfishEngine.onmessage = prevHandler; } catch(e) {}
            if (timeoutId) clearTimeout(timeoutId);
            engineBusy = false;
            reject(err);
          }
        }
      };

      try {
        stockfishEngine.onmessage = capture;
        stockfishEngine.postMessage('position fen ' + fen);
        // use movetime; also ask for info during search (stockfish will emit info)
        stockfishEngine.postMessage('go movetime ' + parseInt(movetimeMs,10));
      } catch (e) {
        try { stockfishEngine.onmessage = prevHandler; } catch(ignore) {}
        engineBusy = false;
        return reject(e);
      }

      // safety timeout
      timeoutId = setTimeout(function() {
        try { stockfishEngine.onmessage = prevHandler; } catch(e) {}
        engineBusy = false;
        reject('timeout');
      }, Math.max(9000, movetimeMs + 5000));
    });
  }

  // -------------------------
  // minimax fallback (kept)
  // -------------------------
  var weights = { p:100,n:280,b:320,r:479,q:929,k:60000,k_e:60000 };
  var pst_w = { /* same PST tables as before (omitted here for brevity in code view) */ 
    p: [[100,100,100,100,105,100,100,100],[78,83,86,73,102,82,85,90],[7,29,21,44,40,31,44,7],[-17,16,-2,15,14,0,15,-13],[-26,3,10,9,6,1,0,-23],[-22,9,5,-11,-10,-2,3,-19],[-31,8,-7,-37,-36,-14,3,-31],[0,0,0,0,0,0,0,0]],
    n: [[-66,-53,-75,-75,-10,-55,-58,-70],[-3,-6,100,-36,4,62,-4,-14],[10,67,1,74,73,27,62,-2],[24,24,45,37,33,41,25,17],[-1,5,31,21,22,35,2,0],[-18,10,13,22,18,15,11,-14],[-23,-15,2,0,2,0,-23,-20],[-74,-23,-26,-24,-19,-35,-22,-69]],
    b: [[-59,-78,-82,-76,-23,-107,-37,-50],[-11,20,35,-42,-39,31,2,-22],[-9,39,-32,41,52,-10,28,-14],[25,17,20,34,26,25,15,10],[13,10,17,23,17,16,0,7],[14,25,24,15,8,25,20,15],[19,20,11,6,7,6,20,16],[-7,2,-15,-12,-14,-15,-10,-10]],
    r: [[35,29,33,4,37,33,56,50],[55,29,56,67,55,62,34,60],[19,35,28,33,45,27,25,15],[0,5,16,13,18,-4,-9,-6],[-28,-35,-16,-21,-13,-29,-46,-30],[-42,-28,-42,-25,-25,-35,-26,-46],[-53,-38,-31,-26,-29,-43,-44,-53],[-30,-24,-18,5,-2,-18,-31,-32]],
    q: [[6,1,-8,-104,69,24,88,26],[14,32,60,-10,20,76,57,24],[-2,43,32,60,72,63,43,2],[1,-16,22,17,25,20,-13,-6],[-14,-15,-2,-5,-1,-10,-20,-22],[-30,-6,-13,-11,-16,-11,-16,-27],[-36,-18,0,-19,-15,-15,-21,-38],[-39,-30,-31,-13,-31,-36,-34,-42]],
    k: [[4,54,47,-99,-99,60,83,-62],[-32,10,55,56,56,55,10,3],[-62,12,-57,44,-67,28,37,-31],[-55,50,11,-4,-19,13,0,-49],[-55,-43,-52,-28,-51,-47,-8,-50],[-47,-42,-43,-79,-64,-32,-29,-32],[-4,3,-14,-50,-57,-18,13,4],[17,30,-3,-14,6,-1,40,18]],
    k_e: [[-50,-40,-30,-20,-20,-30,-40,-50],[-30,-20,-10,0,0,-10,-20,-30],[-30,-10,20,30,30,20,-10,-30],[-30,-10,30,40,40,30,-10,-30],[-30,-10,30,40,40,30,-10,-30],[-30,-10,20,30,30,20,-10,-30],[-30,-30,0,0,0,0,-30,-30],[-50,-30,-30,-30,-30,-30,-30,-50]]
  };
  var pst_b = { p: pst_w['p'].slice().reverse(), n: pst_w['n'].slice().reverse(), b: pst_w['b'].slice().reverse(), r: pst_w['r'].slice().reverse(), q: pst_w['q'].slice().reverse(), k: pst_w['k'].slice().reverse(), k_e: pst_w['k_e'].slice().reverse() };
  var pstOpponent = { w: pst_b, b: pst_w };
  var pstSelf = { w: pst_w, b: pst_b };

  function evaluateBoard(game, move, prevSum, color) {
    if (game.in_checkmate()) { if (move.color === color) return 1e10; else return -1e10; }
    if (game.in_draw() || game.in_threefold_repetition() || game.in_stalemate()) return 0;
    if (game.in_check()) { if (move.color === color) prevSum += 50; else prevSum -= 50; }
    var from = [8 - parseInt(move.from[1]), move.from.charCodeAt(0) - 'a'.charCodeAt(0)];
    var to = [8 - parseInt(move.to[1]), move.to.charCodeAt(0) - 'a'.charCodeAt(0)];
    if (prevSum < -1500 && move.piece === 'k') move.piece = 'k_e';
    if ('captured' in move) {
      if (move.color === color) prevSum += weights[move.captured] + pstOpponent[move.color][move.captured][to[0]][to[1]];
      else prevSum -= weights[move.captured] + pstSelf[move.color][move.captured][to[0]][to[1]];
    }
    if (move.flags && move.flags.includes('p')) {
      move.promotion = 'q';
      if (move.color === color) {
        prevSum -= weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum += weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]];
      } else {
        prevSum += weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum -= weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]];
      }
    } else {
      if (move.color !== color) {
        prevSum += pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum -= pstSelf[move.color][move.piece][to[0]][to[1]];
      } else {
        prevSum -= pstSelf[move.color][move.piece][from[0]][from[1]];
        prevSum += pstSelf[move.color][move.piece][to[0]][to[1]];
      }
    }
    return prevSum;
  }

  function minimax(game, depth, alpha, beta, isMax, sum, color) {
    var children = game.ugly_moves({ verbose: true });
    children.sort(function(){ return 0.5 - Math.random(); });
    if (depth === 0 || children.length === 0) return [null, sum];
    var maxV = Number.NEGATIVE_INFINITY, minV = Number.POSITIVE_INFINITY, best = null;
    for (var i=0;i<children.length;i++){
      var m = children[i];
      var pm = game.ugly_move(m);
      var newSum = evaluateBoard(game, pm, sum, color);
      var [, childVal] = minimax(game, depth-1, alpha, beta, !isMax, newSum, color);
      game.undo();
      if (isMax) {
        if (childVal > maxV) { maxV = childVal; best = pm; }
        if (childVal > alpha) alpha = childVal;
      } else {
        if (childVal < minV) { minV = childVal; best = pm; }
        if (childVal < beta) beta = childVal;
      }
      if (alpha >= beta) break;
    }
    return isMax ? [best, maxV] : [best, minV];
  }
  function getBestMoveMinimax(game, color, currSum) {
    var depth = 2;
    return minimax(game, depth, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, true, currSum, color)[0];
  }

  // -------------------------
  // UI init
  // -------------------------
  (async function init() {
    try { await resolveAllPieces(); } catch(e){ console.error('resolve pieces failed', e); }
    initStockfish();

    var defaultAny=null; for (var k in pieceImgResolved) if (pieceImgResolved[k]) { defaultAny = pieceImgResolved[k]; break; }

    function pieceTheme(piece) {
      if (pieceImgResolved && pieceImgResolved[piece]) return pieceImgResolved[piece];
      return defaultAny;
    }

    var config = {
      draggable:true,
      position:'start',
      pieceTheme:pieceTheme,
      moveSpeed:250,
      snapbackSpeed:200,
      snapSpeed:100,
      onDragStart: function(source, piece) {
        if (inputLocked) return false;
        try {
          if (game.game_over()) return false;
          if (!piece) return false;
          if ((game.turn()==='w' && piece.search(/^b/)!==-1) || (game.turn()==='b' && piece.search(/^w/)!==-1)) return false;
        } catch (e) {
          console.warn('onDragStart guard triggered', e);
          return false;
        }
      },
      onDrop: function(source, target) {
        if (inputLocked) return 'snapback';
        var move = game.move({from:source, to:target, promotion:'q'});
        if (move === null) { playSound('incorrect'); return 'snapback'; }
        // record capture (if any)
        recordCapture(move);
        // lock input and start processing
        inputLocked = true;
        doMoveLogic(move, source, target, true);
        return;
      },
      onSnapEnd: function() { board.position(game.fen()); }
    };
    board = Chessboard('myBoard', config);
    setTimeout(function(){ $('#myBoard .chessboard-js-piece').css('transition','top 0.25s, left 0.25s'); }, 1000);

    // controls
    document.getElementById('copyPgnBtn').addEventListener('click', function(){
      try {
        navigator.clipboard.writeText(game.pgn() || '').then(function(){ alert('PGN copied'); }, function(){ alert('Copy failed'); });
      } catch (e) { alert('Copy not available'); }
    });
    document.getElementById('resetBtn').addEventListener('click', function(){
      resetGame();
    });
    document.getElementById('engineMode').addEventListener('change', function(e){
      aiMode = e.target.value;
    });

    // initial render
    updatePGNTable();
    renderCapturedUI();
    updateEvaluationFromEngine({cp:0});
  })();

  // -------------------------
  // sounds/effects/move logic
  // -------------------------
  function playSound(type) {
    var el=null;
    switch(type){
      case 'move': el=document.getElementById('moveSound'); break;
      case 'capture': el=document.getElementById('captureSound'); break;
      case 'promote': el=document.getElementById('promoteSound'); break;
      case 'castling': el=document.getElementById('castlingSound'); break;
      case 'incorrect': el=document.getElementById('incorrectMoveSound'); break;
      case 'check': el=document.getElementById('checkSound'); break;
      case 'checkmate': el=document.getElementById('checkmateSound'); break;
    }
    if (el) { el.currentTime = 0; el.play().catch(()=>{}); }
  }

  function boardMoveEffect(square) {
    var $sq = $('#myBoard .square-' + square);
    $sq.addClass('move-effect');
    setTimeout(function(){ $sq.removeClass('move-effect'); }, 400);
  }

  function playMoveEffectAndSound(move) {
    if (move.flags.includes('k') || move.flags.includes('q')) playSound('castling');
    else if (move.flags.includes('p')) playSound('promote');
    else if (move.flags.includes('c') || move.flags.includes('e')) playSound('capture');
    else playSound('move');
    if (game.in_checkmate()) playSound('checkmate');
    else if (game.in_check()) playSound('check');
  }

  // record captured pieces from a move object (verbose move)
  function recordCapture(move) {
    if (!move) return;
    if ('captured' in move && move.captured) {
      if (move.color === 'w') {
        capturedByWhite.push(move.captured);
      } else {
        capturedByBlack.push(move.captured);
      }
      // update UI captured lists and material diff
      renderCapturedUI();
    }
  }

  function renderCapturedUI() {
    var wlist = document.getElementById('whiteCapturesList');
    var blist = document.getElementById('blackCapturesList');
    wlist.innerHTML = '';
    blist.innerHTML = '';

    var matWhite = 0, matBlack = 0;
    capturedByWhite.forEach(function(pc){
      var key = 'b' + pc.toUpperCase();
      var img = document.createElement('img'); img.src = pieceImgResolved[key] || pieceImgResolved['bP']; img.alt = pc;
      wlist.appendChild(img);
      matWhite += (materialVals[pc] || 0);
    });
    capturedByBlack.forEach(function(pc){
      var key = 'w' + pc.toUpperCase();
      var img = document.createElement('img'); img.src = pieceImgResolved[key] || pieceImgResolved['wP']; img.alt = pc;
      blist.appendChild(img);
      matBlack += (materialVals[pc] || 0);
    });

    // Show +N only on the side which currently has MORE captured material
    var whiteBadge = document.getElementById('whiteAdvBadge');
    var blackBadge = document.getElementById('blackAdvBadge');
    if (matWhite > matBlack) {
      whiteBadge.innerText = '+' + (matWhite - matBlack);
      blackBadge.innerText = '';
    } else if (matBlack > matWhite) {
      blackBadge.innerText = '+' + (matBlack - matWhite);
      whiteBadge.innerText = '';
    } else {
      whiteBadge.innerText = ''; blackBadge.innerText = '';
    }

    // material diff (white - black) for info panel
    var diff = matWhite - matBlack;
    document.getElementById('matDiff').innerText = (diff>0? '+'+diff : diff.toString());
  }

  // core: robust doMoveLogic with locks and guaranteed unlock
  async function doMoveLogic(move, source, target, isDrag) {
    if (processingMove) { console.warn('doMoveLogic re-entry blocked'); return; }
    processingMove = true;
    try {
      playMoveEffectAndSound(move);
      boardMoveEffect(source);
      boardMoveEffect(target);
      globalSum = evaluateBoard(game, move, globalSum, 'b');

      if (!isDrag) board.position(game.fen());

      clearHighlights();
      selectedSquare = null;

      // allow small delay for UI to settle, then compute bot move
      await new Promise(r => setTimeout(r, 300));

      if (game.game_over() || game.turn() !== 'b') {
        inputLocked = false;
        processingMove = false;
        updatePGNTable();
        return;
      }

      // prefer stockfish if ready
      if (aiMode === 'stockfish' && stockfishEngine && engineReady) {
        try {
          var fen = game.fen();
          console.log('Requesting SF bestmove for fen:', fen);
          var best = await stockfishBestMove(fen, stockfishMovetime).catch(function(e){ console.warn('SF query failed:', e); return null; });
          console.log('Stockfish answered bestmove:', best);

          if (best && best !== '(none)') {
            var from = best.slice(0,2);
            var to = best.slice(2,4);
            var promotion = (best.length > 4) ? best[4] : null;

            // Validate against legal moves
            var legals = game.moves({ verbose: true });
            var matched = null;
            for (var i = 0; i < legals.length; i++) {
              var m = legals[i];
              if (m.from === from && m.to === to) {
                if (promotion) {
                  if (m.promotion && m.promotion === promotion.toLowerCase()) { matched = m; break; }
                } else { matched = m; break; }
              }
            }

            if (matched) {
              console.log('Applying SF move (validated):', matched);
              var botMove = game.move({ from: matched.from, to: matched.to, promotion: matched.promotion || 'q' });
              if (botMove) {
                // record capture for bot move if any
                recordCapture(botMove);
                playMoveEffectAndSound(botMove);
                boardMoveEffect(botMove.from);
                boardMoveEffect(botMove.to);
                globalSum = evaluateBoard(game, botMove, globalSum, 'b');
                board.position(game.fen());
                inputLocked = false; // unlock after bot move applied
                updatePGNTable();
                processingMove = false;
                return;
              } else {
                console.warn('game.move returned null despite matched legal move:', matched);
              }
            } else {
              console.warn('Stockfish suggested move not found in legal moves:', best);
            }
          } else {
            console.warn('Stockfish returned no usable bestmove:', best);
          }
        } catch (e) {
          console.warn('Stockfish error during move apply -> fallback to minimax', e);
        }
      }

      // fallback minimax
      if (!game.game_over() && game.turn() === 'b') {
        var mmMoveObj = getBestMoveMinimax(game, 'b', globalSum);
        if (mmMoveObj) {
          var applied = game.move(mmMoveObj);
          if (!applied) applied = game.move({ from: mmMoveObj.from, to: mmMoveObj.to, promotion: mmMoveObj.promotion || 'q' });
          if (applied) {
            recordCapture(applied);
            playMoveEffectAndSound(applied);
            boardMoveEffect(applied.from);
            boardMoveEffect(applied.to);
            globalSum = evaluateBoard(game, applied, globalSum, 'b');
            board.position(game.fen());
          } else {
            console.warn('Minimax returned move but could not apply it.', mmMoveObj);
          }
        } else {
          console.warn('Minimax did not return move — position may be terminal.');
        }
      }

      // unlock input finally
      inputLocked = false;
      updatePGNTable();
    } finally {
      processingMove = false;
    }
  }

  // -------------------------
  // click-to-move handlers (respect inputLocked)
  // -------------------------
  var selectedSquare = null;
  var legalTargets = [];

  function clearHighlights() { $('#myBoard .square-55d63').removeClass('highlight-click highlight-target'); }
  function highlightSquares(squares, cls){ squares.forEach(function(sq){ $('#myBoard .square-' + sq).addClass(cls); }); }

  $('#myBoard').on('click', '.square-55d63', function() {
    if (inputLocked) return; // ignore clicks while locked
    var square = $(this).attr('data-square');
    if (game.game_over()) return;
    if (!selectedSquare) {
      var piece = game.get(square);
      if (!piece || piece.color !== game.turn()) return;
      selectedSquare = square;
      clearHighlights();
      $('#myBoard .square-' + square).addClass('highlight-click');
      var moves = game.moves({ square: square, verbose: true });
      legalTargets = moves.map(function(m){ return m.to; });
      highlightSquares(legalTargets, 'highlight-target');
    } else {
      if (square === selectedSquare) { selectedSquare = null; legalTargets = []; clearHighlights(); return; }
      if (legalTargets.includes(square)) {
        var move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
        if (move === null) { playSound('incorrect'); clearHighlights(); selectedSquare=null; legalTargets=[]; board.position(game.fen()); return; }
        recordCapture(move);
        // lock input and process
        inputLocked = true;
        doMoveLogic(move, selectedSquare, square, false);
        return;
      }
      var piece2 = game.get(square);
      if (piece2 && piece2.color === game.turn()) {
        selectedSquare = square;
        clearHighlights();
        $('#myBoard .square-' + square).addClass('highlight-click');
        var moves = game.moves({ square: square, verbose: true });
        legalTargets = moves.map(function(m){ return m.to; });
        highlightSquares(legalTargets, 'highlight-target');
        return;
      }
      selectedSquare = null; legalTargets = []; clearHighlights();
    }
  });

  $(document).on('click', function(e){ if ($(e.target).closest('#myBoard').length === 0) { clearHighlights(); selectedSquare=null; legalTargets=[]; } });
  $('#myBoard').on('mousedown', '.square-55d63', function(){ clearHighlights(); selectedSquare=null; legalTargets=[]; });

  // -------------------------
  // PGN table updates
  // -------------------------
  function updatePGNTable() {
    var body = document.getElementById('pgnBody');
    body.innerHTML = '';
    var history = game.history(); // SAN array
    var rows = Math.ceil(history.length / 2);
    for (var i=0;i<rows;i++){
      var moveNum = i+1;
      var whiteMove = history[i*2] || '';
      var blackMove = history[i*2 + 1] || '';
      var tr = document.createElement('tr');
      var tdNum = document.createElement('td'); tdNum.className = 'move-num'; tdNum.innerText = moveNum + '.';
      var tdW = document.createElement('td'); tdW.innerText = whiteMove;
      var tdB = document.createElement('td'); tdB.innerText = blackMove;
      tr.appendChild(tdNum); tr.appendChild(tdW); tr.appendChild(tdB);
      body.appendChild(tr);
    }
    var scroll = document.querySelector('.pgn-table-wrap');
    if (scroll) scroll.scrollTop = scroll.scrollHeight;
  }

  // -------------------------
  // evaluation bar helper
  // -------------------------
  function updateEvaluationFromEngine(obj) {
    // obj = { cp: number } or { mate: number }
    var fill = document.getElementById('evalFill');
    var label = document.getElementById('evalLabel');
    if (!fill || !label) return;
    if (obj.mate !== undefined) {
      // show mate prominently
      var m = obj.mate;
      var sign = (m>0? '+':'');
      label.innerText = 'M' + sign + m;
      fill.style.height = (m>0? '100%' : '0%');
      if (m>0) fill.classList.remove('black'); else fill.classList.add('black');
      return;
    }
    var cp = obj.cp || 0;
    // map cp to percent with soft scaling
    // cp range -1000 .. +1000 maps to 0..100, center 0 => 50%
    var percent = 50 + (cp / 20); // gentler scaling
    if (percent > 100) percent = 100;
    if (percent < 0) percent = 0;
    fill.style.height = percent + '%';
    if (percent >= 50) fill.classList.remove('black'); else fill.classList.add('black');
    var sign = (cp > 0 ? '+' : '');
    label.innerText = sign + cp + ' cp';
  }

  function updateEvalFromGlobalSum() {
    var cp = Math.round(globalSum / 10); // convert internal weights to approx centipawns
    updateEvaluationFromEngine({cp: cp});
  }

  // -------------------------
  // reset / helper
  // -------------------------
  function resetGame() {
    game.reset();
    board.position('start');
    capturedByWhite = [];
    capturedByBlack = [];
    globalSum = 0;
    renderCapturedUI();
    updatePGNTable();
    updateEvaluationFromEngine({cp:0});
    inputLocked = false;
    processingMove = false;
  }

  // expose some debug on window for testing
  window._debug = {
    updateEvalFromGlobalSum: updateEvalFromGlobalSum,
    resetGame: resetGame,
    capturedByWhite: capturedByWhite,
    capturedByBlack: capturedByBlack
  };
  </script>
</body>
</html>
