<!DOCTYPE html>
<html lang="en">
<head>
    <title>Chess Bot Minimal + Click + Sound + Effect</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Chessboard JS CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" crossorigin="anonymous">
    <style>
        body {
            background: #fafafa;
        }
        .board-container {
            max-width: 420px;
            margin: 60px auto 0 auto;
        }
        #myBoard {
            width: 100%;
            min-width: 320px;
            min-height: 320px;
        }
        .highlight-click {
            box-shadow: 0 0 8px 4px orange inset;
        }
        .highlight-target {
            box-shadow: 0 0 4px 2px green inset;
        }
        .move-effect {
            animation: boardMoveEffect 0.4s;
        }
        @keyframes boardMoveEffect {
            0% { box-shadow: 0 0 10px 4px #33dd33 inset; }
            100% { box-shadow: none; }
        }
    </style>
</head>
<body>
    <div class="board-container">
        <div id="myBoard"></div>
    </div>
    <!-- Sound Effects -->
    <audio id="moveSound" src="sounds/move.mp3"></audio>
    <audio id="captureSound" src="sounds/capture.mp3"></audio>
    <audio id="promoteSound" src="sounds/promote.mp3"></audio>
    <audio id="castlingSound" src="sounds/castling.mp3"></audio>
    <audio id="incorrectMoveSound" src="sounds/incorrect-move.mp3"></audio>
    <audio id="checkSound" src="sounds/check.mp3"></audio>
    <audio id="checkmateSound" src="sounds/checkmate.mp3"></audio>
    <!-- jQuery for Chessboard.js -->
    <script src="https://code.jquery.com/jquery-3.5.1.js" crossorigin="anonymous"></script>
    <!-- Chessboard JS -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js" crossorigin="anonymous"></script>
    <!-- Local chess.js -->
    <script src="js/chess.js"></script>
    <script>
    // ===== Pieces config =====
    var pieceImgConfig = {
      'wK': 'pieces/wK.svg',
      'wQ': 'pieces/wQ.svg',
      'wR': 'pieces/wR.svg',
      'wB': 'pieces/wB.svg',
      'wN': 'pieces/wN.svg',
      'wP': 'pieces/wP.svg',
      'bK': 'pieces/bK.svg',
      'bQ': 'pieces/bQ.svg',
      'bR': 'pieces/bR.svg',
      'bB': 'pieces/bB.svg',
      'bN': 'pieces/bN.svg',
      'bP': 'pieces/bP.svg'
    };

    // ===== Chess AI Logic =====
    var weights = { p: 100, n: 280, b: 320, r: 479, q: 929, k: 60000, k_e: 60000 };
    var pst_w = {
      p: [[100,100,100,100,105,100,100,100],[78,83,86,73,102,82,85,90],[7,29,21,44,40,31,44,7],[-17,16,-2,15,14,0,15,-13],[-26,3,10,9,6,1,0,-23],[-22,9,5,-11,-10,-2,3,-19],[-31,8,-7,-37,-36,-14,3,-31],[0,0,0,0,0,0,0,0]],
      n: [[-66,-53,-75,-75,-10,-55,-58,-70],[-3,-6,100,-36,4,62,-4,-14],[10,67,1,74,73,27,62,-2],[24,24,45,37,33,41,25,17],[-1,5,31,21,22,35,2,0],[-18,10,13,22,18,15,11,-14],[-23,-15,2,0,2,0,-23,-20],[-74,-23,-26,-24,-19,-35,-22,-69]],
      b: [[-59,-78,-82,-76,-23,-107,-37,-50],[-11,20,35,-42,-39,31,2,-22],[-9,39,-32,41,52,-10,28,-14],[25,17,20,34,26,25,15,10],[13,10,17,23,17,16,0,7],[14,25,24,15,8,25,20,15],[19,20,11,6,7,6,20,16],[-7,2,-15,-12,-14,-15,-10,-10]],
      r: [[35,29,33,4,37,33,56,50],[55,29,56,67,55,62,34,60],[19,35,28,33,45,27,25,15],[0,5,16,13,18,-4,-9,-6],[-28,-35,-16,-21,-13,-29,-46,-30],[-42,-28,-42,-25,-25,-35,-26,-46],[-53,-38,-31,-26,-29,-43,-44,-53],[-30,-24,-18,5,-2,-18,-31,-32]],
      q: [[6,1,-8,-104,69,24,88,26],[14,32,60,-10,20,76,57,24],[-2,43,32,60,72,63,43,2],[1,-16,22,17,25,20,-13,-6],[-14,-15,-2,-5,-1,-10,-20,-22],[-30,-6,-13,-11,-16,-11,-16,-27],[-36,-18,0,-19,-15,-15,-21,-38],[-39,-30,-31,-13,-31,-36,-34,-42]],
      k: [[4,54,47,-99,-99,60,83,-62],[-32,10,55,56,56,55,10,3],[-62,12,-57,44,-67,28,37,-31],[-55,50,11,-4,-19,13,0,-49],[-55,-43,-52,-28,-51,-47,-8,-50],[-47,-42,-43,-79,-64,-32,-29,-32],[-4,3,-14,-50,-57,-18,13,4],[17,30,-3,-14,6,-1,40,18]],
      k_e: [[-50,-40,-30,-20,-20,-30,-40,-50],[-30,-20,-10,0,0,-10,-20,-30],[-30,-10,20,30,30,20,-10,-30],[-30,-10,30,40,40,30,-10,-30],[-30,-10,30,40,40,30,-10,-30],[-30,-10,20,30,30,20,-10,-30],[-30,-30,0,0,0,0,-30,-30],[-50,-30,-30,-30,-30,-30,-30,-50]]
    };
    var pst_b = {
      p: pst_w['p'].slice().reverse(),
      n: pst_w['n'].slice().reverse(),
      b: pst_w['b'].slice().reverse(),
      r: pst_w['r'].slice().reverse(),
      q: pst_w['q'].slice().reverse(),
      k: pst_w['k'].slice().reverse(),
      k_e: pst_w['k_e'].slice().reverse(),
    };
    var pstOpponent = { w: pst_b, b: pst_w };
    var pstSelf = { w: pst_w, b: pst_b };

    var board = null;
    var game = new Chess();
    var globalSum = 0; // from black's perspective

    // Sound play helper
    function playSound(type) {
      var el = null;
      switch(type) {
        case "move": el = document.getElementById("moveSound"); break;
        case "capture": el = document.getElementById("captureSound"); break;
        case "promote": el = document.getElementById("promoteSound"); break;
        case "castling": el = document.getElementById("castlingSound"); break;
        case "incorrect": el = document.getElementById("incorrectMoveSound"); break;
        case "check": el = document.getElementById("checkSound"); break;
        case "checkmate": el = document.getElementById("checkmateSound"); break;
      }
      if (el) { el.currentTime = 0; el.play(); }
    }

    // Effect helper
    function boardMoveEffect(square) {
      var $sq = $('#myBoard .square-' + square);
      $sq.addClass('move-effect');
      setTimeout(function() { $sq.removeClass('move-effect'); }, 400);
    }

    function evaluateBoard(game, move, prevSum, color) {
      if (game.in_checkmate()) {
        if (move.color === color) return 1e10;
        else return -1e10;
      }
      if (game.in_draw() || game.in_threefold_repetition() || game.in_stalemate()) return 0;
      if (game.in_check()) {
        if (move.color === color) prevSum += 50;
        else prevSum -= 50;
      }
      var from = [8 - parseInt(move.from[1]), move.from.charCodeAt(0) - 'a'.charCodeAt(0)];
      var to = [8 - parseInt(move.to[1]), move.to.charCodeAt(0) - 'a'.charCodeAt(0)];
      if (prevSum < -1500 && move.piece === 'k') move.piece = 'k_e';
      if ('captured' in move) {
        if (move.color === color) {
          prevSum += weights[move.captured] + pstOpponent[move.color][move.captured][to[0]][to[1]];
        } else {
          prevSum -= weights[move.captured] + pstSelf[move.color][move.captured][to[0]][to[1]];
        }
      }
      if (move.flags && move.flags.includes('p')) {
        move.promotion = 'q';
        if (move.color === color) {
          prevSum -= weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]];
          prevSum += weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]];
        } else {
          prevSum += weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]];
          prevSum -= weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]];
        }
      } else {
        if (move.color !== color) {
          prevSum += pstSelf[move.color][move.piece][from[0]][from[1]];
          prevSum -= pstSelf[move.color][move.piece][to[0]][to[1]];
        } else {
          prevSum -= pstSelf[move.color][move.piece][from[0]][from[1]];
          prevSum += pstSelf[move.color][move.piece][to[0]][to[1]];
        }
      }
      return prevSum;
    }

    function minimax(game, depth, alpha, beta, isMaximizingPlayer, sum, color) {
      var children = game.ugly_moves({ verbose: true });
      children.sort(function () { return 0.5 - Math.random(); });
      if (depth === 0 || children.length === 0) return [null, sum];
      var maxValue = Number.NEGATIVE_INFINITY, minValue = Number.POSITIVE_INFINITY, bestMove;
      for (var i = 0; i < children.length; i++) {
        var currMove = children[i];
        var currPrettyMove = game.ugly_move(currMove);
        var newSum = evaluateBoard(game, currPrettyMove, sum, color);
        var [, childValue] = minimax(game, depth - 1, alpha, beta, !isMaximizingPlayer, newSum, color);
        game.undo();
        if (isMaximizingPlayer) {
          if (childValue > maxValue) { maxValue = childValue; bestMove = currPrettyMove; }
          if (childValue > alpha) alpha = childValue;
        } else {
          if (childValue < minValue) { minValue = childValue; bestMove = currPrettyMove; }
          if (childValue < beta) beta = childValue;
        }
        if (alpha >= beta) break;
      }
      return isMaximizingPlayer ? [bestMove, maxValue] : [bestMove, minValue];
    }

    function getBestMove(game, color, currSum) {
      var depth = 2;
      var [bestMove, ] = minimax(game, depth, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, true, currSum, color);
      return bestMove;
    }

    // ===== Chessboard JS Config =====
    var config = {
      draggable: true,
      position: 'start',
      pieceTheme: function(piece) {
        return pieceImgConfig[piece];
      },
      onDragStart: function(source, piece) {
        if (game.game_over()) return false;
        if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
            (game.turn() === 'b' && piece.search(/^w/) !== -1)) return false;
      },
      onDrop: function(source, target) {
        return handleMove(source, target, "drag");
      },
      onSnapEnd: function() {
        board.position(game.fen());
      }
    };
    board = Chessboard('myBoard', config);

    // ===== Piece Move Logic (drag+click) + Sound + Effects =====
    function handleMove(source, target, moveType) {
      // Try to move
      var move = game.move({ from: source, to: target, promotion: 'q' });
      if (move === null) {
        playSound("incorrect");
        clearHighlights();
        return 'snapback';
      }
      // Sound + Effect for player move
      playMoveEffectAndSound(move);
      boardMoveEffect(source);
      boardMoveEffect(target);
      globalSum = evaluateBoard(game, move, globalSum, 'b');
      board.position(game.fen());
      clearHighlights();
      // Bot move
      setTimeout(function() {
        if (!game.game_over() && game.turn() === 'b') {
          var botMove = getBestMove(game, 'b', globalSum);
          if (botMove) {
            game.move(botMove);
            playMoveEffectAndSound(botMove);
            boardMoveEffect(botMove.from);
            boardMoveEffect(botMove.to);
            globalSum = evaluateBoard(game, botMove, globalSum, 'b');
            board.position(game.fen());
          }
        }
      }, 300);
      selectedSquare = null;
      return;
    }

    // Sound/Effect logic for move
    function playMoveEffectAndSound(move) {
      // Castling
      if (move.flags.includes('k') || move.flags.includes('q')) {
        playSound("castling");
      } 
      // Promotion
      else if (move.flags.includes('p')) {
        playSound("promote");
      } 
      // Capture
      else if (move.flags.includes('c') || move.flags.includes('e')) {
        playSound("capture");
      } 
      // Normal
      else {
        playSound("move");
      }
      // Check/Checkmate
      if (game.in_checkmate()) {
        playSound("checkmate");
      } else if (game.in_check()) {
        playSound("check");
      }
    }

    // ===== Click-to-move implementation =====
    var selectedSquare = null;
    var legalTargets = [];

    function clearHighlights() {
      $('#myBoard .square-55d63').removeClass('highlight-click');
      $('#myBoard .square-55d63').removeClass('highlight-target');
    }

    function highlightSquares(squares, highlightClass) {
      squares.forEach(function(sq) {
        $('#myBoard .square-' + sq).addClass(highlightClass);
      });
    }

    // Square click logic
    $('#myBoard').on('click', '.square-55d63', function() {
      var square = $(this).attr('data-square');
      if (game.game_over()) return;
      clearHighlights();

      if (!selectedSquare) {
        var piece = game.get(square);
        // Only select your own piece
        if (!piece || piece.color !== game.turn()) return;
        selectedSquare = square;
        $('#myBoard .square-' + square).addClass('highlight-click');

        // Highlight legal targets
        var moves = game.moves({ square: square, verbose: true });
        legalTargets = moves.map(function(move) { return move.to; });
        highlightSquares(legalTargets, 'highlight-target');
      } else {
        // If clicked on same square, deselect
        if (square === selectedSquare) {
          selectedSquare = null;
          legalTargets = [];
          clearHighlights();
          return;
        }
        // If clicked on a legal target, move
        if (legalTargets.includes(square)) {
          handleMove(selectedSquare, square, "click");
        } else {
          // If clicked on another own piece, switch selection
          var piece2 = game.get(square);
          if (piece2 && piece2.color === game.turn()) {
            selectedSquare = square;
            $('#myBoard .square-' + square).addClass('highlight-click');
            var moves = game.moves({ square: square, verbose: true });
            legalTargets = moves.map(function(move) { return move.to; });
            highlightSquares(legalTargets, 'highlight-target');
          } else {
            // invalid target, deselect
            selectedSquare = null;
            legalTargets = [];
            clearHighlights();
          }
        }
      }
    });

    // Allow drag and click to work side by side
    $('#myBoard').on('mousedown', '.square-55d63', function() {
      clearHighlights();
      selectedSquare = null;
      legalTargets = [];
    });

    </script>
</body>
</html>
