
<!DOCTYPE html>
<html lang="bn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GConnect — Chess Analysis Board</title>

  <!-- Chessboard.js CSS -->
  <link rel="stylesheet"
        href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
        crossorigin="anonymous">

  <style>
    :root{
      --bg:#0f1416; --card:#13181a; --muted:#9aa4a8; --accent:#00b894;
    }
    html,body{height:100%;background:var(--bg);color:#e6eef0;font-family:Inter,Helvetica,Arial,sans-serif;margin:0;padding:18px;}
    .container{max-width:1200px;margin:0 auto;}
    h3{margin-bottom:12px;}
    .card{background:var(--card);border-radius:12px;color:inherit;padding:12px;margin-bottom:12px;box-shadow:0 8px 24px rgba(0,0,0,.5);}
    textarea{width:100%;min-height:120px;background:transparent;border:1px solid #223;padding:10px;border-radius:8px;color:inherit;resize:vertical;}
    .controls{display:flex;gap:8px;flex-wrap:wrap;}
    .btn{background:#128c7e;border:0;padding:8px 12px;border-radius:8px;color:white;cursor:pointer;}
    .btn.secondary{background:#3a3f44;}
    #board{width:420px;margin:0 auto;}
    .progress {height:10px;background:#0a0d0e;border-radius:6px;overflow:hidden;}
    .progress-bar{height:100%;background:linear-gradient(90deg,#00b894,#2dd4bf);width:0%;}
    .small-muted{color:var(--muted);font-size:.9rem;}
    .move-card{margin-bottom:8px;border-radius:10px;padding:8px;background:#0f1718;display:flex;align-items:center;gap:10px;cursor:pointer;}
    .move-cat{font-weight:700;padding:6px 8px;border-radius:6px;font-size:.8rem;display:inline-flex;align-items:center;gap:8px;}
    .cat-icon{width:22px;height:22px;border-radius:50%;overflow:hidden;}
    .analysis-text{color:#dfeff0;margin-top:6px;white-space:pre-wrap;}
    .stat-pill{background:#0c1716;padding:6px 8px;border-radius:999px;font-weight:600;font-size:.85rem;margin-right:6px;}
  </style>
</head>
<body>
  <div class="container">
    <h3>GConnect — Chess Analysis Board</h3>

    <div class="card">
      <div style="display:flex;gap:12px;flex-wrap:wrap;">
        <div style="flex:1;">
          <div class="small-muted">PGN পেস্ট করুন (headers থাকলে player নামও পড়ে নেওয়া হবে)</div>
          <textarea id="pgnInput" placeholder='[White "player1"]&#10;[Black "player2"]&#10;1. e4 e5 2. Nf3 Nc6 ...'></textarea>
        </div>
        <div style="width:300px;">
          <div style="display:flex;flex-direction:column;gap:8px;">
            <button id="analyzeBtn" class="btn">Analyze PGN</button>
            <button id="clearBtn" class="btn secondary">Clear</button>
            <div id="pgnMeta" class="small-muted" style="margin-top:8px;"></div>
            <div class="small-muted" style="margin-top:8px">Pieces: local <code>./pieces/{piece}.svg</code> (wK.svg, bP.svg ...) — নথি না থাকলে CDN fallback নেওয়া হবে।</div>
          </div>
        </div>
      </div>
    </div>

    <div class="card" style="display:flex;gap:16px;flex-wrap:wrap;">
      <div style="flex:1;min-width:320px;">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <strong>Board</strong>
          <div id="moveIndex" class="small-muted">Move 0 / 0</div>
        </div>
        <div id="board" style="margin-top:12px;"></div>

        <div class="controls" style="justify-content:center;margin-top:12px;">
          <button id="firstBtn" class="btn secondary">⏮ First</button>
          <button id="prevBtn" class="btn secondary">◀ Prev</button>
          <button id="nextBtn" class="btn secondary">Next ▶</button>
          <button id="lastBtn" class="btn secondary">Last ⏭</button>
          <button id="undoBtn" class="btn secondary">Undo ↶</button>
          <button id="redoBtn" class="btn secondary">Redo ↷</button>
        </div>

        <div style="margin-top:12px;">
          <div class="small-muted">AI evaluation for current move</div>
          <div class="card" style="background:#0d1415;margin-top:8px;">
            <div id="currentCategory" style="display:inline-block;padding:8px;"></div>
            <div id="currentComment" class="analysis-text" style="padding:8px 10px;color:#cfeee0">No analysis yet.</div>
          </div>
        </div>
      </div>

      <div style="width:420px;min-width:320px;">
        <div class="card">
          <strong>Analysis Progress</strong>
          <div style="margin-top:8px;" class="small-muted">মোট half-moves বিশ্লেষণ করা হচ্ছে</div>
          <div style="margin-top:12px;">
            <div class="progress"><div id="progressBarEl" class="progress-bar"></div></div>
            <div id="progressText" class="small-muted" style="margin-top:8px">Idle</div>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <strong>Players & Stats</strong>
          <div style="margin-top:8px;">
            <div style="display:flex;gap:10px;align-items:center;">
              <img id="whiteAvatar" src="https://picsum.photos/seed/white/64" alt="white" style="width:48px;height:48px;border-radius:50%"/>
              <div>
                <div><strong id="whiteName">White</strong></div>
                <div id="whiteAccuracy" class="small-muted">Accuracy: —</div>
                <div id="whiteStats" style="margin-top:8px;display:flex;flex-wrap:wrap;"></div>
              </div>
            </div>

            <hr style="border-color:#0b1514;margin:10px 0"/>

            <div style="display:flex;gap:10px;align-items:center;">
              <img id="blackAvatar" src="https://picsum.photos/seed/black/64" alt="black" style="width:48px;height:48px;border-radius:50%"/>
              <div>
                <div><strong id="blackName">Black</strong></div>
                <div id="blackAccuracy" class="small-muted">Accuracy: —</div>
                <div id="blackStats" style="margin-top:8px;display:flex;flex-wrap:wrap;"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <strong>Moves (click to jump)</strong>
          <div class="small-muted" style="margin-top:8px">কমেন্ট বোর্ডে দেখাবে</div>
          <div id="movesList" style="margin-top:12px;max-height:360px;overflow:auto;"></div>
        </div>

        <div class="card" style="margin-top:12px;">
          <strong>Summary</strong>
          <div id="summaryBox" class="small-muted" style="margin-top:8px">No summary yet.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- libs -->
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
  <script src="./chess.js"></script>

  <script>
    // Category icon CDN (Bootstrap Icons)
    const categoryIconMap = {
      'Brilliant':'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/icons/star-fill.svg',
      'Great':'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/icons/trophy-fill.svg',
      'Best':'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/icons/check-circle-fill.svg',
      'Inaccuracy':'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/icons/dash-circle-fill.svg',
      'Mistake':'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/icons/exclamation-triangle-fill.svg',
      'Miss':'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/icons/question-circle-fill.svg',
      'Blunder':'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/icons/x-circle-fill.svg',
      'Equal':'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/icons/record-circle-fill.svg'
    };

    // App state
    let boardWidget = null;
    let movesSAN = [];    // half-moves SAN
    let fens = ['start']; // fen sequence (index 0 startpos)
    let analysisResults = []; // per half-move {category, score, comment}
    let currentIndex = 0;
    let undoStack = [], redoStack = [];
    let analyzedCount = 0; // to keep accurate progress

    // DOM refs
    const progressBarEl = document.getElementById('progressBarEl');
    const progressText = document.getElementById('progressText');
    const movesList = document.getElementById('movesList');

    // Helper: detect if local pieces exist (HEAD sample request)
    async function detectLocalPieces() {
      const sampleUrls = ['./pieces/wP.svg','./pieces/bP.svg'];
      for (const u of sampleUrls) {
        try {
          const r = await fetch(u, { method: 'HEAD' });
          if (r.ok) return './pieces/{piece}.svg';
        } catch(e){}
      }
      return 'https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/img/chesspieces/wikipedia/{piece}.png';
    }

    async function initBoard(){
      const themeUrl = await detectLocalPieces();
      if(boardWidget && typeof boardWidget.destroy === 'function') boardWidget.destroy();
      boardWidget = Chessboard('board', { draggable:false, position:'start', pieceTheme: themeUrl });
      console.log('Using piece theme:', themeUrl);
    }
    initBoard();

    function setProgress(pct,text){
      progressBarEl.style.width = pct + '%';
      progressText.textContent = text || '';
    }

    function escapeHtml(s){ if(!s) return ''; return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]); }

    // PGN header parser
    function parseHeaders(pgn){
      const headers = {};
      const re = /^\[([A-Za-z0-9_]+)\s+"([^"]*)"\]/gm;
      let m;
      while((m = re.exec(pgn)) !== null) headers[m[1]] = m[2];
      return headers;
    }

    // parse PGN using chess.js (half-moves history)
    function parsePGNandBuild(pgn){
      const t = new Chess();
      const ok = t.load_pgn(pgn);
      if(!ok) throw new Error('Invalid PGN: could not load');
      const history = t.history(); // half-moves SAN array
      const headers = parseHeaders(pgn);
      // rebuild from start so we can record FENs
      const g = new Chess();
      if(headers.SetUp === '1' && headers.FEN) g.load(headers.FEN); else g.reset();
      const fensLocal = [g.fen()];
      const movesLocal = [];
      for(const san of history){
        const res = g.move(san);
        if(!res) throw new Error('Failed applying move: ' + san);
        movesLocal.push(san);
        fensLocal.push(g.fen());
      }
      return { headers, movesSAN: movesLocal, fens: fensLocal };
    }

    // Build messages (system+user) for model
    function buildMessages(fen, san, plyIndex){
      const system = {
        role: "system",
        content: `You are GConnect Chess Analysis Assistant. OUTPUT EXACTLY one JSON object and nothing else. Keys: category, score, comment.
category must be one of ["Brilliant","Great","Best","Inaccuracy","Mistake","Miss","Blunder","Equal"].
score: integer centipawn or null.
comment: concise (max 2 sentences). Add a short encouraging phrase for positive categories.`
      };
      const user = {
        role: "user",
        content: `FEN: ${fen}\nMove: ${san}\nPlyIndex: ${plyIndex}\nReturn JSON only.`
      };
      return [system, user];
    }

    // CLIENT-SIDE: call server proxy to analyze a single move (with retry)
    async function analyzeMove(fen, san, plyIndex){
      const cacheKey = fen + '|' + san;
      // call server
      const body = { model: "openai/gpt-oss-120b:together", messages: buildMessages(fen, san, plyIndex), max_tokens: 300, temperature:0.2 };
      const maxRetries = 3;
      for(let attempt=1; attempt<=maxRetries; attempt++){
        try {
          const resp = await fetch('/api/query', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
          if(!resp.ok) throw new Error('Server returned '+resp.status);
          const json = await resp.json();
          // server returns { result:..., replyText: '...' }
          let txt = '';
          if(json.replyText) txt = json.replyText;
          else if(json.result && json.result.choices && json.result.choices[0] && json.result.choices[0].message) txt = json.result.choices[0].message.content || '';
          else if(typeof json === 'string') txt = json;
          // try parse JSON from text
          let parsed = null;
          try { parsed = JSON.parse(txt.trim()); }
          catch(e){
            const m = txt.match(/\{[\s\S]*\}/);
            if(m){
              try { parsed = JSON.parse(m[0]); } catch(e2){ parsed = null; }
            }
          }
          if(parsed && typeof parsed === 'object'){
            const category = (parsed.category || 'Equal').toString().trim();
            const score = (typeof parsed.score === 'number') ? parsed.score : (parsed.score ? Number(parsed.score) : null);
            let comment = (parsed.comment || '').toString().trim();
            comment = comment.replace(/^[\s"'`]+|[\s"'`]+$/g,'');
            const sentences = comment.split(/(?<=\.)\s+/);
            comment = sentences.slice(0,2).join(' ').trim();
            if(['Brilliant','Great','Best'].includes(category) && !/well|good|strong|brilliant|excellent|great/i.test(comment)) comment += ' Great idea — well played!';
            return { category, score, comment };
          } else {
            // fallback: raw text as comment
            let fallback = (txt || '').toString().trim().replace(/\s+/g,' ').slice(0,400);
            fallback = fallback.replace(/^[\s"']+|[\s"']+$/g,'');
            return { category:'Equal', score:null, comment: fallback || 'No clear analysis.' };
          }
        } catch(err){
          console.warn('analyzeMove attempt',attempt,'failed',err);
          if(attempt===maxRetries) return { category:'Equal', score:null, comment:'Analysis failed after retries.' };
          await new Promise(r=>setTimeout(r, 500 * attempt));
        }
      }
      return { category:'Equal', score:null, comment:'Analysis unavailable.' };
    }

    // Render moves list
    function renderMovesList(){
      movesList.innerHTML = '';
      for(let i=0;i<movesSAN.length;i++){
        const ply = i+1;
        const san = movesSAN[i];
        const a = analysisResults[i] || { category:'Pending', comment:'Waiting...' };
        const icon = categoryIconMap[a.category] || categoryIconMap['Equal'];
        const node = document.createElement('div');
        node.className = 'move-card';
        node.innerHTML = `
          <div style="width:44px;text-align:center;">
            <div style="font-size:.9rem">${ply}</div>
            <div style="font-size:.75rem;color:var(--muted)">${(ply%2===1)?'W':'B'}</div>
          </div>
          <div style="width:40px;display:flex;align-items:center;justify-content:center;">
            <div class="cat-icon"><img src="${icon}" width="22" /></div>
          </div>
          <div style="flex:1">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div><strong>${escapeHtml(san)}</strong></div>
              <div><span class="move-cat">${escapeHtml(a.category||'Pending')}</span></div>
            </div>
            <div class="analysis-text" style="font-size:.9rem;color:#cfeee0">${escapeHtml((a.comment||'').slice(0,120))}</div>
          </div>
        `;
        node.onclick = ()=> setPosition(ply);
        movesList.appendChild(node);
      }
    }

    // Update board UI
    function updateUI(){
      const total = Math.max(0, fens.length-1);
      document.getElementById('moveIndex').textContent = `Move ${currentIndex} / ${total}`;
      const fen = fens[currentIndex] || 'start';
      try { boardWidget.position(fen); } catch(e){ console.warn('board.position error', e); }
      if(currentIndex === 0){
        document.getElementById('currentCategory').innerHTML = '';
        document.getElementById('currentComment').textContent = 'Start position.';
      } else {
        const analysis = analysisResults[currentIndex-1] || {category:'—', comment:'Waiting...'};
        const cat = analysis.category || '—';
        const icon = categoryIconMap[cat] || categoryIconMap['Equal'];
        document.getElementById('currentCategory').innerHTML = `<span class="move-cat"><span class="cat-icon" style="margin-right:6px;"><img src="${icon}" width="18" /></span> ${escapeHtml(cat)}</span>`;
        document.getElementById('currentComment').textContent = analysis.comment || 'Waiting...';
      }
      // highlight move in list
      Array.from(movesList.children).forEach((el, idx) => {
        el.style.outline = (idx+1 === currentIndex) ? '2px solid rgba(255,255,255,.04)' : 'none';
      });
    }

    function setPosition(idx){
      if(idx < 0) idx = 0;
      if(idx > fens.length-1) idx = fens.length-1;
      undoStack.push(currentIndex);
      currentIndex = idx;
      redoStack = [];
      updateUI();
    }

    // nav buttons
    document.getElementById('firstBtn').onclick = ()=> setPosition(0);
    document.getElementById('lastBtn').onclick = ()=> setPosition(Math.max(0, fens.length-1));
    document.getElementById('prevBtn').onclick = ()=> setPosition(Math.max(0, currentIndex-1));
    document.getElementById('nextBtn').onclick = ()=> setPosition(Math.min(fens.length-1, currentIndex+1));
    document.getElementById('undoBtn').onclick = ()=> { if(undoStack.length){ redoStack.push(currentIndex); currentIndex = undoStack.pop(); updateUI(); } };
    document.getElementById('redoBtn').onclick = ()=> { if(redoStack.length){ undoStack.push(currentIndex); currentIndex = redoStack.pop(); updateUI(); } };

    // compute stats & accuracy
    function computeStatsAndRender(){
      const cats = ['Brilliant','Great','Best','Inaccuracy','Mistake','Miss','Blunder','Equal'];
      const whiteCounts = {}; const blackCounts = {}; cats.forEach(c=>{ whiteCounts[c]=0; blackCounts[c]=0; });
      for(let i=0;i<analysisResults.length;i++){
        const a = analysisResults[i] || {category:'Equal'};
        const cat = a.category || 'Equal';
        const ply = i+1;
        if(ply % 2 === 1) whiteCounts[cat] = (whiteCounts[cat]||0) + 1;
        else blackCounts[cat] = (blackCounts[cat]||0) + 1;
      }
      const whiteTotal = Object.values(whiteCounts).reduce((s,v)=>s+v,0) || 0;
      const blackTotal = Object.values(blackCounts).reduce((s,v)=>s+v,0) || 0;
      const whiteErrors = (whiteCounts['Mistake']||0) + (whiteCounts['Miss']||0) + (whiteCounts['Blunder']||0);
      const blackErrors = (blackCounts['Mistake']||0) + (blackCounts['Miss']||0) + (blackCounts['Blunder']||0);
      const whiteAcc = whiteTotal ? Math.max(0, Math.round((1 - (whiteErrors/whiteTotal))*100)) : '—';
      const blackAcc = blackTotal ? Math.max(0, Math.round((1 - (blackErrors/blackTotal))*100)) : '—';
      document.getElementById('whiteAccuracy').textContent = `Accuracy: ${whiteAcc === '—' ? '—' : whiteAcc + '%'}`;
      document.getElementById('blackAccuracy').textContent = `Accuracy: ${blackAcc === '—' ? '—' : blackAcc + '%'}`;
      const whiteStatsEl = document.getElementById('whiteStats'); const blackStatsEl = document.getElementById('blackStats');
      whiteStatsEl.innerHTML=''; blackStatsEl.innerHTML='';
      cats.forEach(c=>{ if(whiteCounts[c]) { const d=document.createElement('div'); d.className='stat-pill'; d.textContent=`${c}: ${whiteCounts[c]}`; whiteStatsEl.appendChild(d);} if(blackCounts[c]){ const d2=document.createElement('div'); d2.className='stat-pill'; d2.textContent=`${c}: ${blackCounts[c]}`; blackStatsEl.appendChild(d2);} });
      document.getElementById('summaryBox').textContent = `Total half-moves: ${analysisResults.length} • White moves: ${whiteTotal} • Black moves: ${blackTotal}`;
    }

    // MAIN ANALYSIS FLOW
    document.getElementById('analyzeBtn').onclick = async () => {
      const pgn = document.getElementById('pgnInput').value.trim();
      if(!pgn){ alert('প্রথমে PGN পেস্ট করুন'); return; }
      try {
        setProgress(2, 'Parsing PGN...');
        const res = parsePGNandBuild(pgn);
        movesSAN = res.movesSAN; fens = res.fens;
        analysisResults = new Array(movesSAN.length).fill(null);
        currentIndex = 0; analyzedCount = 0;
        await initBoard(); boardWidget.position(fens[0]);
        updateUI();
        // headers -> players
        document.getElementById('pgnMeta').textContent = `${res.headers.White || 'White'} vs ${res.headers.Black || 'Black'} • ${movesSAN.length} half-moves`;
        document.getElementById('whiteName').textContent = res.headers.White || 'White';
        document.getElementById('blackName').textContent = res.headers.Black || 'Black';
        document.getElementById('whiteAvatar').src = `https://picsum.photos/seed/${encodeURIComponent(res.headers.White||'white')}/64`;
        document.getElementById('blackAvatar').src = `https://picsum.photos/seed/${encodeURIComponent(res.headers.Black||'black')}/64`;

        // iterate sequentially and update accurate progress using analyzedCount
        for(let i=0;i<movesSAN.length;i++){
          const ply = i+1;
          // optimistic progress while waiting: use analyzedCount
          setProgress(Math.round((analyzedCount / movesSAN.length) * 100), `Analyzing ${analyzedCount}/${movesSAN.length} (waiting for ${ply})`);
          const fenBefore = fens[i];
          const san = movesSAN[i];
          const out = await analyzeMove(fenBefore, san, ply);
          analysisResults[i] = out;
          analyzedCount = analysisResults.filter(x=>x && x.category).length;
          // update UI incrementally
          renderMovesList();
          computeStatsAndRender();
          setProgress(Math.round((analyzedCount / movesSAN.length) * 100), `Analyzed ${analyzedCount}/${movesSAN.length}`);
          updateUI();
        }
        // finalize
        setProgress(100, `Analysis complete (${analyzedCount}/${movesSAN.length})`);
        renderMovesList(); computeStatsAndRender(); updateUI();
      } catch(err){
        console.error(err);
        alert('Analysis failed: ' + (err.message || err));
        setProgress(0, 'Failed');
      }
    };

    // clear
    document.getElementById('clearBtn').onclick = async () => {
      document.getElementById('pgnInput').value = '';
      movesSAN = []; fens = ['start']; analysisResults = []; currentIndex = 0; analyzedCount = 0;
      await initBoard(); updateUI(); renderMovesList();
      setProgress(0,'Idle');
      document.getElementById('pgnMeta').textContent = '';
      document.getElementById('whiteName').textContent = 'White'; document.getElementById('blackName').textContent = 'Black';
      document.getElementById('whiteAvatar').src = 'https://picsum.photos/seed/white/64';
      document.getElementById('blackAvatar').src = 'https://picsum.photos/seed/black/64';
      document.getElementById('whiteStats').innerHTML=''; document.getElementById('blackStats').innerHTML='';
      document.getElementById('whiteAccuracy').textContent = 'Accuracy: —'; document.getElementById('blackAccuracy').textContent = 'Accuracy: —';
    };

    // initialise small UI state
    setProgress(0,'Idle');
  </script>
</body>
</html>
